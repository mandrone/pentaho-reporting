diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/ant/.ant.properties itext-1.5.2-jdk12/ant/.ant.properties
--- itext-1.5.2/ant/.ant.properties	2007-04-27 15:56:00.000000000 +0200
+++ itext-1.5.2-jdk12/ant/.ant.properties	2007-06-13 21:06:10.000000000 +0200
@@ -1,4 +1,4 @@
-itext.home=../..
+itext.home=./..
 
 itext.src=${itext.home}/src
 itext.www=${itext.home}/www
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/ant/compile.xml itext-1.5.2-jdk12/ant/compile.xml
--- itext-1.5.2/ant/compile.xml	2007-06-20 12:53:00.000000000 +0200
+++ itext-1.5.2-jdk12/ant/compile.xml	2007-10-08 12:43:58.000000000 +0200
@@ -1,124 +1,152 @@
-<?xml version="1.0"?>
-
-<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-<!-- iText, a JAVA - PDF library                                      -->
-<!-- $Id: compile.xml,v 1.13 2006/09/25 21:08:07 xlv Exp $         -->
-<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-
-<project name="iText.compile" default="help">
-	
-	<property file=".ant.properties" />
-	
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <!-- Help                                                             -->
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-
-    <target name="help" description="--> shows the help screen">
-        <echo>COMPILING AND JARRING THE CODE (compile.xml)</echo>
-        <echo>ant compile: compiles iText</echo>
-        <echo>ant compile.debug: compiles iText and allows you to debug the code</echo>
-        <echo>ant jar: compiles and jars iText</echo>
-        <echo>ant jar.debug: compiles for debugging and jars iText</echo>
-        <echo />
-	</target>
-
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <!-- Compiling the code                                               -->
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-
-    <target name="compile" description="--> compiles the iText code">
-        <mkdir dir="${itext.classes}" />
-        <javac source="1.4" target="1.4" srcdir="${itext.src}" destdir="${itext.classes}" />
-    </target>
-
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <!-- Compiling the code for debugging                                 -->
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-
-    <target name="compile.debug" description="--> compiles the iText code for debugging">
-        <mkdir dir="${itext.classes}" />
-        <javac source="1.4" target="1.4" srcdir="${itext.src}" destdir="${itext.classes}" listfiles="yes" debug="true" debuglevel="lines,vars,source" />
-    </target>
-
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <!-- Jarring the code                                                 -->
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-
-    <target name="make.jar" description="--> makes a jarfile from the iText code">
-        <mkdir dir="${itext.bin}" />
-        <mkdir dir="${itext.classes}/com/lowagie/text/pdf/fonts" />
-        <copy todir="${itext.classes}/com/lowagie/text/pdf/fonts" overwrite="yes">
-            <fileset dir="${itext.src}/com/lowagie/text/pdf/fonts">
-                <include name="**/*.afm"/>
-                <include name="**/*.html"/>
-            </fileset>
-        </copy>
-        <copy todir="${itext.classes}/com/lowagie/text/" overwrite="yes">
-            <fileset dir="${itext.src}/com/lowagie/text">
-                <include name="**/*.txt"/>
-            </fileset>
-        </copy>
-        <copy todir="${itext.classes}/com/lowagie/" overwrite="yes">
-            <fileset dir="${itext.src}/com/lowagie">
-                <include name="**/*.txt"/>
-            </fileset>
-        </copy>
-        <jar jarfile="${itext.bin}/iText.jar" basedir="${itext.classes}" manifest="../META-INF/MANIFEST.MF" excludes="com/lowagie/examples/**,**/*.cmap,**/*.properties,com/lowagie/text/pdf/fonts/cmaps/**" />
-    </target>
-
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <!-- Compiling and Jarring the code                                   -->
-	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-	
-    <target name="jar"  depends="compile, make.jar" description="--> makes a jarfile from the iText code" />
-
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <!-- Jarring the code (debug)                                         -->
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-	
-    <target name="jar.debug"  depends="compile.debug, make.jar" description="--> makes a jarfile from the iText code" />
-
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <!-- Updating the JavaCC generated files for the postscript grammar   -->
-    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
-    <target name="update-parser" description="updates the JavaCC generated files for the postscript grammar" >
-        <fail message="JavaCC location is not defined properly">
-            <condition>
-                <not>
-                    <available file="${javacc.home}" type="dir" />
-                </not>
-            </condition>
-        </fail>
-
-        <property name="parser_input.dir" value="${itext.src}/com/lowagie/text/pdf/codec/postscript" />
-        <property name="parser_output.dir" value="${itext.build}/parser" />
-
-        <mkdir dir="${parser_output.dir}" />
-        <javacc
-            target="${parser_input.dir}/paparser.jj"
-            outputdirectory="${parser_output.dir}"
-            javacchome="${javacc.home}"
-            static="false" />
-
-        <macrodef name="insertlicense">
-            <attribute name="name"/>
-            <sequential>
-                <concat destfile="${parser_input.dir}/@{name}">
-                    <filelist dir="${parser_input.dir}" files="license.txt"/>
-                    <filelist dir="${parser_output.dir}" files="@{name}"/>
-                </concat>
-            </sequential>
-        </macrodef>
-
-        <insertlicense name="JavaCharStream.java" />
-        <insertlicense name="PAParser.java" />
-        <insertlicense name="PAParserConstants.java" />
-        <insertlicense name="PAParserTokenManager.java" />
-        <insertlicense name="ParseException.java" />
-        <insertlicense name="Token.java" />
-        <insertlicense name="TokenMgrError.java" />
-
-        <delete dir="${parser_output.dir}" />
-    </target>
-
-</project>
+<?xml version="1.0"?>
+
+<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+<!-- iText, a JAVA - PDF library                                      -->
+<!-- $Id: compile.xml,v 1.13 2006/09/25 21:08:07 xlv Exp $         -->
+<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+
+<project name="iText.compile" default="help">
+	
+	<property file=".ant.properties" />
+	
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <!-- Help                                                             -->
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+
+    <target name="help" description="--> shows the help screen">
+        <echo>COMPILING AND JARRING THE CODE (compile.xml)</echo>
+        <echo>ant compile: compiles iText</echo>
+        <echo>ant compile.debug: compiles iText and allows you to debug the code</echo>
+        <echo>ant jar: compiles and jars iText</echo>
+        <echo>ant jar.debug: compiles for debugging and jars iText</echo>
+        <echo />
+	</target>
+
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <!-- Compiling the code                                               -->
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+
+    <target name="compile" description="--> compiles the iText code">
+        <mkdir dir="${itext.classes}" />
+<!--        <javac source="1.4" target="1.4" srcdir="${itext.src}" destdir="${itext.classes}" /> -->
+      <javac  fork="true"
+              memoryInitialSize="160m"
+              memoryMaximumSize="160m"
+              srcdir="${itext.src}" destdir="${itext.classes}"
+              compiler="jikes"
+              nowarn="on"
+      	      includeAntRuntime="false"
+	            includeJavaRuntime="false"
+              deprecation="true"
+              debug="true"
+              optimize="false"
+              target="1.2">
+        <bootclasspath>
+	  <pathelement location="/opt/jdk1.2.2/jre/lib/rt.jar"/>
+	</bootclasspath>
+      </javac>
+
+    </target>
+
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <!-- Compiling the code for debugging                                 -->
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+
+    <target name="compile.debug" description="--> compiles the iText code for debugging">
+        <mkdir dir="${itext.classes}" />
+        <javac source="1.4" target="1.4" srcdir="${itext.src}" destdir="${itext.classes}" listfiles="yes" debug="true" debuglevel="lines,vars,source" />
+      <javac  fork="true"
+              memoryInitialSize="160m"
+              memoryMaximumSize="160m"
+              srcdir="${itext.src}" destdir="${itext.classes}"
+              compiler="jikes"
+              nowarn="on"
+      	      includeAntRuntime="false"
+	            includeJavaRuntime="false"
+              deprecation="true"
+              debug="true"
+              optimize="false"
+              target="1.2">
+        <bootclasspath>
+	  <pathelement location="/opt/jdk1.2.2/jre/lib/rt.jar"/>
+	</bootclasspath>
+      </javac>
+    </target>
+
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <!-- Jarring the code                                                 -->
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+
+    <target name="make.jar" description="--> makes a jarfile from the iText code">
+        <mkdir dir="${itext.bin}" />
+        <mkdir dir="${itext.classes}/com/lowagie/text/pdf/fonts" />
+        <copy todir="${itext.classes}/com/lowagie/text/pdf/fonts" overwrite="yes">
+            <fileset dir="${itext.src}/com/lowagie/text/pdf/fonts">
+                <include name="**/*.afm"/>
+                <include name="**/*.html"/>
+            </fileset>
+        </copy>
+        <copy todir="${itext.classes}/com/lowagie/text/" overwrite="yes">
+            <fileset dir="${itext.src}/com/lowagie/text/">
+                <include name="**/*.txt"/>
+            </fileset>
+        </copy>
+        <jar jarfile="${itext.bin}/iText.jar" basedir="${itext.classes}" manifest="../META-INF/MANIFEST.MF" excludes="com/lowagie/examples/**,**/*.cmap,**/*.properties,com/lowagie/text/pdf/fonts/cmaps/**" />
+    </target>
+
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <!-- Compiling and Jarring the code                                   -->
+	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+	
+    <target name="jar"  depends="compile, make.jar" description="--> makes a jarfile from the iText code" />
+
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <!-- Jarring the code (debug)                                         -->
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+	
+    <target name="jar.debug"  depends="compile.debug, make.jar" description="--> makes a jarfile from the iText code" />
+
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <!-- Updating the JavaCC generated files for the postscript grammar   -->
+    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
+    <target name="update-parser" description="updates the JavaCC generated files for the postscript grammar" >
+        <fail message="JavaCC location is not defined properly">
+            <condition>
+                <not>
+                    <available file="${javacc.home}" type="dir" />
+                </not>
+            </condition>
+        </fail>
+
+        <property name="parser_input.dir" value="${itext.src}/com/lowagie/text/pdf/codec/postscript" />
+        <property name="parser_output.dir" value="${itext.build}/parser" />
+
+        <mkdir dir="${parser_output.dir}" />
+        <javacc
+            target="${parser_input.dir}/paparser.jj"
+            outputdirectory="${parser_output.dir}"
+            javacchome="${javacc.home}"
+            static="false" />
+
+        <macrodef name="insertlicense">
+            <attribute name="name"/>
+            <sequential>
+                <concat destfile="${parser_input.dir}/@{name}">
+                    <filelist dir="${parser_input.dir}" files="license.txt"/>
+                    <filelist dir="${parser_output.dir}" files="@{name}"/>
+                </concat>
+            </sequential>
+        </macrodef>
+
+        <insertlicense name="JavaCharStream.java" />
+        <insertlicense name="PAParser.java" />
+        <insertlicense name="PAParserConstants.java" />
+        <insertlicense name="PAParserTokenManager.java" />
+        <insertlicense name="ParseException.java" />
+        <insertlicense name="Token.java" />
+        <insertlicense name="TokenMgrError.java" />
+
+        <delete dir="${parser_output.dir}" />
+    </target>
+
+</project>
Binärdateien itext-1.5.2/lib/xml-apis.jar and itext-1.5.2-jdk12/lib/xml-apis.jar sind verschieden.
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/Document.java itext-1.5.2-jdk12/src/com/lowagie/text/Document.java
--- itext-1.5.2/src/com/lowagie/text/Document.java	2007-06-20 12:54:00.000000000 +0200
+++ itext-1.5.2-jdk12/src/com/lowagie/text/Document.java	2007-05-20 08:46:03.000000000 +0200
@@ -102,7 +102,7 @@
     // membervariables
     
 	/** This constant may only be changed by Paulo Soares and/or Bruno Lowagie. */
-	private static final String ITEXT_VERSION = "iText 1.5.2 (release for Eclipse/BIRT by lowagie.com)";
+	private static final String ITEXT_VERSION = "iText 1.5.2 (released for Eclipse/BIRT by lowagie.com)";
     
 	/**
 	 * Allows the pdf documents to be produced without compression for debugging
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/pdf/MappedRandomAccessFile.java itext-1.5.2-jdk12/src/com/lowagie/text/pdf/MappedRandomAccessFile.java
--- itext-1.5.2/src/com/lowagie/text/pdf/MappedRandomAccessFile.java	2006-09-15 22:09:00.000000000 +0200
+++ itext-1.5.2-jdk12/src/com/lowagie/text/pdf/MappedRandomAccessFile.java	2007-06-13 20:46:17.000000000 +0200
@@ -1,216 +1,217 @@
-/*
- * $Id: MappedRandomAccessFile.java,v 1.4 2006/09/15 20:09:01 xlv Exp $
- *
- * Copyright 2006 Joakim Sandstroem
- *
- * The contents of this file are subject to the Mozilla Public License Version 1.1
- * (the "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the License.
- *
- * The Original Code is 'iText, a free JAVA-PDF library'.
- *
- * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
- * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
- * All Rights Reserved.
- * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
- * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
- *
- * Contributor(s): all the names of the contributors are added in the source code
- * where applicable.
- *
- * Alternatively, the contents of this file may be used under the terms of the
- * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
- * provisions of LGPL are applicable instead of those above.  If you wish to
- * allow use of your version of this file only under the terms of the LGPL
- * License and not to allow others to use your version of this file under
- * the MPL, indicate your decision by deleting the provisions above and
- * replace them with the notice and other provisions required by the LGPL.
- * If you do not delete the provisions above, a recipient may use your version
- * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
- *
- * This library is free software; you can redistribute it and/or modify it
- * under the terms of the MPL as stated above or under the terms of the GNU
- * Library General Public License as published by the Free Software Foundation;
- * either version 2 of the License, or any later version.
- *
- * This library is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
- * details.
- *
- * If you didn't download this code from the following link, you should check if
- * you aren't using an obsolete version:
- * http://www.lowagie.com/iText/
- */
-package com.lowagie.text.pdf;
-
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.nio.BufferUnderflowException;
-import java.nio.MappedByteBuffer;
-import java.nio.channels.FileChannel;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
-/**
- * A {@link java.nio.MappedByteBuffer} wrapped as a {@link java.io.RandomAccessFile}
- *
- * @author Joakim Sandstroem
- * Created on 6.9.2006
- */
-public class MappedRandomAccessFile {
-    
-    private MappedByteBuffer mappedByteBuffer = null;
-    private FileChannel channel = null;
-    
-    /**
-     * Constructs a new MappedRandomAccessFile instance
-     * @param filename String
-     * @param mode String r, w or rw
-     * @throws FileNotFoundException
-     * @throws IOException
-     */
-    public MappedRandomAccessFile(String filename, String mode)
-    throws FileNotFoundException, IOException {
-        
-        if (mode.equals("rw"))
-            init(
-                    new java.io.RandomAccessFile(filename, mode).getChannel(),
-                    FileChannel.MapMode.READ_WRITE);
-        else
-            init(
-                    new FileInputStream(filename).getChannel(),
-                    FileChannel.MapMode.READ_ONLY);
-        
-    }
-    
-    /**
-     * initializes the channel and mapped bytebuffer
-     * @param channel FileChannel
-     * @param mapMode FileChannel.MapMode
-     * @throws IOException
-     */
-    private void init(FileChannel channel, FileChannel.MapMode mapMode)
-    throws IOException {
-        
-        this.channel = channel;
-        this.mappedByteBuffer = channel.map(mapMode, 0L, channel.size());
-        mappedByteBuffer.load();
-    }
-    
-    /**
-     * @see java.io.RandomAccessFile#read()
-     * @return int next integer or -1 on EOF
-     */
-    public int read() {
-        try {
-            byte b = mappedByteBuffer.get();
-            int n = b & 0xff;
-            
-            return n;
-        } catch (BufferUnderflowException e) {
-            return -1; // EOF
-        }
-    }
-    
-    /**
-     * @see java.io.RandomAccessFile#read(byte[], int, int)
-     * @param bytes byte[]
-     * @param off int offset
-     * @param len int length
-     * @return int bytes read or -1 on EOF
-     */
-    public int read(byte bytes[], int off, int len) {
-        int pos = mappedByteBuffer.position();
-        int limit = mappedByteBuffer.limit();
-        if (pos == limit)
-            return -1; // EOF
-        int newlimit = pos + len - off;
-        if (newlimit > limit) {
-            len = limit - pos; // don't read beyond EOF
-        }
-        mappedByteBuffer.get(bytes, off, len);
-        return len;
-    }
-    
-    /**
-     * @see java.io.RandomAccessFile#getFilePointer()
-     * @return long
-     */
-    public long getFilePointer() {
-        return mappedByteBuffer.position();
-    }
-    
-    /**
-     * @see java.io.RandomAccessFile#seek(long)
-     * @param pos long position
-     */
-    public void seek(long pos) {
-        mappedByteBuffer.position((int) pos);
-    }
-    
-    /**
-     * @see java.io.RandomAccessFile#length()
-     * @return long length
-     */
-    public long length() {
-        return mappedByteBuffer.limit();
-    }
-    
-    /**
-     * @see java.io.RandomAccessFile#close()
-     * Cleans the mapped bytebuffer and closes the channel
-     */
-    public void close() throws IOException {
-        clean(mappedByteBuffer);
-        mappedByteBuffer = null;
-        channel.close();
-        channel = null;
-    }
-    
-    /**
-     * invokes the close method
-     * @see java.lang.Object#finalize()
-     */
-    protected void finalize() throws Throwable {
-        close();
-        super.finalize();
-    }
-    
-    /**
-     * invokes the clean method on the ByteBuffer's cleaner
-     * @param buffer ByteBuffer
-     * @return boolean true on success
-     */
-    public static boolean clean(final java.nio.ByteBuffer buffer) {
-        if (buffer == null || !buffer.isDirect())
-            return false;
-        
-        Boolean b = (Boolean) AccessController.doPrivileged(new PrivilegedAction() {
-            public Object run() {
-                Boolean success = Boolean.FALSE;
-                try {
-                    Method getCleanerMethod = buffer.getClass().getMethod("cleaner", null);
-                    getCleanerMethod.setAccessible(true);
-                    Object cleaner = getCleanerMethod.invoke(buffer, null);
-                    Method clean = cleaner.getClass().getMethod("clean", null);
-                    clean.invoke(cleaner, null);
-                    success = Boolean.TRUE;
-                } catch (Exception e) {
-                    // This really is a show stopper on windows
-                    //e.printStackTrace();
-                }
-                return success;
-            }
-        });
-        
-        return b.booleanValue();
-    }
-    
-}
+///*
+// * $Id: MappedRandomAccessFile.java,v 1.4 2006/09/15 20:09:01 xlv Exp $
+// *
+// * Copyright 2006 Joakim Sandstroem
+// *
+// * The contents of this file are subject to the Mozilla Public License Version 1.1
+// * (the "License"); you may not use this file except in compliance with the License.
+// * You may obtain a copy of the License at http://www.mozilla.org/MPL/
+// *
+// * Software distributed under the License is distributed on an "AS IS" basis,
+// * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+// * for the specific language governing rights and limitations under the License.
+// *
+// * The Original Code is 'iText, a free JAVA-PDF library'.
+// *
+// * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
+// * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
+// * All Rights Reserved.
+// * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
+// * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
+// *
+// * Contributor(s): all the names of the contributors are added in the source code
+// * where applicable.
+// *
+// * Alternatively, the contents of this file may be used under the terms of the
+// * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
+// * provisions of LGPL are applicable instead of those above.  If you wish to
+// * allow use of your version of this file only under the terms of the LGPL
+// * License and not to allow others to use your version of this file under
+// * the MPL, indicate your decision by deleting the provisions above and
+// * replace them with the notice and other provisions required by the LGPL.
+// * If you do not delete the provisions above, a recipient may use your version
+// * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
+// *
+// * This library is free software; you can redistribute it and/or modify it
+// * under the terms of the MPL as stated above or under the terms of the GNU
+// * Library General Public License as published by the Free Software Foundation;
+// * either version 2 of the License, or any later version.
+// *
+// * This library is distributed in the hope that it will be useful, but WITHOUT
+// * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+// * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
+// * details.
+// *
+// * If you didn't download this code from the following link, you should check if
+// * you aren't using an obsolete version:
+// * http://www.lowagie.com/iText/
+// */
+//package com.lowagie.text.pdf;
+//
+//import java.io.FileInputStream;
+//import java.io.FileNotFoundException;
+//import java.io.IOException;
+//import java.lang.reflect.Method;
+//import java.nio.BufferUnderflowException;
+//import java.nio.MappedByteBuffer;
+//import java.nio.channels.FileChannel;
+//import java.security.AccessController;
+//import java.security.PrivilegedAction;
+//
+///**
+// * A {@link java.nio.MappedByteBuffer} wrapped as a {@link java.io.RandomAccessFile}
+// *
+// * @author Joakim Sandstroem
+// * Created on 6.9.2006
+// */
+//public class MappedRandomAccessFile implements RandomAccessFileWrapper
+//{
+//
+//    private MappedByteBuffer mappedByteBuffer = null;
+//    private FileChannel channel = null;
+//
+//    /**
+//     * Constructs a new MappedRandomAccessFile instance
+//     * @param filename String
+//     * @param mode String r, w or rw
+//     * @throws FileNotFoundException
+//     * @throws IOException
+//     */
+//    public MappedRandomAccessFile(String filename, String mode)
+//    throws FileNotFoundException, IOException {
+//        
+//        if (mode.equals("rw"))
+//            init(
+//                    new java.io.RandomAccessFile(filename, mode).getChannel(),
+//                    FileChannel.MapMode.READ_WRITE);
+//        else
+//            init(
+//                    new FileInputStream(filename).getChannel(),
+//                    FileChannel.MapMode.READ_ONLY);
+//
+//    }
+//
+//    /**
+//     * initializes the channel and mapped bytebuffer
+//     * @param channel FileChannel
+//     * @param mapMode FileChannel.MapMode
+//     * @throws IOException
+//     */
+//    private void init(FileChannel channel, FileChannel.MapMode mapMode)
+//    throws IOException {
+//
+//        this.channel = channel;
+//        this.mappedByteBuffer = channel.map(mapMode, 0L, channel.size());
+//        mappedByteBuffer.load();
+//    }
+//
+//    /**
+//     * @see java.io.RandomAccessFile#read()
+//     * @return int next integer or -1 on EOF
+//     */
+//    public int read() {
+//        try {
+//            byte b = mappedByteBuffer.get();
+//            int n = b & 0xff;
+//
+//            return n;
+//        } catch (BufferUnderflowException e) {
+//            return -1; // EOF
+//        }
+//    }
+//
+//    /**
+//     * @see java.io.RandomAccessFile#read(byte[], int, int)
+//     * @param bytes byte[]
+//     * @param off int offset
+//     * @param len int length
+//     * @return int bytes read or -1 on EOF
+//     */
+//    public int read(byte bytes[], int off, int len) {
+//        int pos = mappedByteBuffer.position();
+//        int limit = mappedByteBuffer.limit();
+//        if (pos == limit)
+//            return -1; // EOF
+//        int newlimit = pos + len - off;
+//        if (newlimit > limit) {
+//            len = limit - pos; // don't read beyond EOF
+//        }
+//        mappedByteBuffer.get(bytes, off, len);
+//        return len;
+//    }
+//
+//    /**
+//     * @see java.io.RandomAccessFile#getFilePointer()
+//     * @return long
+//     */
+//    public long getFilePointer() {
+//        return mappedByteBuffer.position();
+//    }
+//
+//    /**
+//     * @see java.io.RandomAccessFile#seek(long)
+//     * @param pos long position
+//     */
+//    public void seek(long pos) {
+//        mappedByteBuffer.position((int) pos);
+//    }
+//
+//    /**
+//     * @see java.io.RandomAccessFile#length()
+//     * @return long length
+//     */
+//    public long length() {
+//        return mappedByteBuffer.limit();
+//    }
+//
+//    /**
+//     * @see java.io.RandomAccessFile#close()
+//     * Cleans the mapped bytebuffer and closes the channel
+//     */
+//    public void close() throws IOException {
+//        clean(mappedByteBuffer);
+//        mappedByteBuffer = null;
+//        channel.close();
+//        channel = null;
+//    }
+//
+//    /**
+//     * invokes the close method
+//     * @see java.lang.Object#finalize()
+//     */
+//    protected void finalize() throws Throwable {
+//        close();
+//        super.finalize();
+//    }
+//
+//    /**
+//     * invokes the clean method on the ByteBuffer's cleaner
+//     * @param buffer ByteBuffer
+//     * @return boolean true on success
+//     */
+//    public static boolean clean(final java.nio.ByteBuffer buffer) {
+//        if (buffer == null || !buffer.isDirect())
+//            return false;
+//
+//        Boolean b = (Boolean) AccessController.doPrivileged(new PrivilegedAction() {
+//            public Object run() {
+//                Boolean success = Boolean.FALSE;
+//                try {
+//                    Method getCleanerMethod = buffer.getClass().getMethod("cleaner", null);
+//                    getCleanerMethod.setAccessible(true);
+//                    Object cleaner = getCleanerMethod.invoke(buffer, null);
+//                    Method clean = cleaner.getClass().getMethod("clean", null);
+//                    clean.invoke(cleaner, null);
+//                    success = Boolean.TRUE;
+//                } catch (Exception e) {
+//                    // This really is a show stopper on windows
+//                    //e.printStackTrace();
+//                }
+//                return success;
+//            }
+//        });
+//
+//        return b.booleanValue();
+//    }
+//
+//}
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/pdf/OldRandomAccessFile.java itext-1.5.2-jdk12/src/com/lowagie/text/pdf/OldRandomAccessFile.java
--- itext-1.5.2/src/com/lowagie/text/pdf/OldRandomAccessFile.java	1970-01-01 01:00:00.000000000 +0100
+++ itext-1.5.2-jdk12/src/com/lowagie/text/pdf/OldRandomAccessFile.java	2007-06-13 20:44:48.000000000 +0200
@@ -0,0 +1,25 @@
+package com.lowagie.text.pdf;
+
+import java.io.RandomAccessFile;
+import java.io.FileNotFoundException;
+import java.io.File;
+
+/**
+ * Creation-Date: 13.06.2007, 20:43:45
+ *
+ * @author Thomas Morgner
+ */
+public class OldRandomAccessFile extends RandomAccessFile implements RandomAccessFileWrapper
+{
+  public OldRandomAccessFile(String name, String mode)
+      throws FileNotFoundException
+  {
+    super(name, mode);
+  }
+
+  public OldRandomAccessFile(File file, String mode)
+      throws FileNotFoundException
+  {
+    super(file, mode);
+  }
+}
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/pdf/PdfCopyFieldsImp.java itext-1.5.2-jdk12/src/com/lowagie/text/pdf/PdfCopyFieldsImp.java
--- itext-1.5.2/src/com/lowagie/text/pdf/PdfCopyFieldsImp.java	2007-06-20 12:42:00.000000000 +0200
+++ itext-1.5.2-jdk12/src/com/lowagie/text/pdf/PdfCopyFieldsImp.java	2006-10-27 19:23:19.000000000 +0200
@@ -112,8 +112,6 @@
     }
     
     void addDocument(PdfReader reader) throws DocumentException {
-    	if (!reader.isOpenedWithFullPermissions())
-    		throw new IllegalArgumentException("PdfReader not opened with owner password");
         openDoc();
         if (readers2intrefs.containsKey(reader)) {
             reader = new PdfReader(reader);
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/pdf/PdfGraphics2D.java itext-1.5.2-jdk12/src/com/lowagie/text/pdf/PdfGraphics2D.java
--- itext-1.5.2/src/com/lowagie/text/pdf/PdfGraphics2D.java	2006-11-11 17:54:00.000000000 +0100
+++ itext-1.5.2-jdk12/src/com/lowagie/text/pdf/PdfGraphics2D.java	2007-06-13 22:14:58.000000000 +0200
@@ -70,7 +70,6 @@
 import java.awt.Stroke;
 import java.awt.TexturePaint;
 import java.awt.Transparency;
-import java.awt.RenderingHints.Key;
 import java.awt.font.FontRenderContext;
 import java.awt.font.GlyphVector;
 import java.awt.font.TextAttribute;
@@ -99,319 +98,377 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+import java.util.Arrays;
 
-public class PdfGraphics2D extends Graphics2D {
-    
-    private static final int FILL = 1;
-    private static final int STROKE = 2;
-    private static final int CLIP = 3;
-    private BasicStroke strokeOne = new BasicStroke(1);
-    
-    private static final AffineTransform IDENTITY = new AffineTransform();
-    
-    private Font font;
-    private BaseFont baseFont;
-    private float fontSize;
-    private AffineTransform transform;
-    private Paint paint;
-    private Color background;
-    private float width;
-    private float height;
-    
-    private Area clip;
-    
-    private RenderingHints rhints = new RenderingHints(null);
-    
-    private Stroke stroke;
-    private Stroke originalStroke;
-    
-    private PdfContentByte cb;
-    
-    /** Storage for BaseFont objects created. */
-    private HashMap baseFonts;
-    
-    private boolean disposeCalled = false;
-    
-    private FontMapper fontMapper;
-    
-    private ArrayList kids;
-    
-    private boolean kid = false;
-    
-    private Graphics2D dg2 = new BufferedImage(2, 2, BufferedImage.TYPE_INT_RGB).createGraphics();
-    
-    private boolean onlyShapes = false;
-    
-    private Stroke oldStroke;
-    private Paint paintFill;
-    private Paint paintStroke;
-    
-    private MediaTracker mediaTracker;
-
-    // Added by Jurij Bilas
-    protected boolean underline;          // indicates if the font style is underlined
-    
-    protected PdfGState fillGState[] = new PdfGState[256];
-    protected PdfGState strokeGState[] = new PdfGState[256];
-    protected int currentFillGState = 255;
-    protected int currentStrokeGState = 255;
-    
-    public static final int AFM_DIVISOR = 1000; // used to calculate coordinates
-
-    private boolean convertImagesToJPEG = false;
-    private float jpegQuality = .95f;
-
-	// Added by Alexej Suchov
-	private float alpha;
-
-	// Added by Alexej Suchov
-	private Composite composite;
-
-	// Added by Alexej Suchov
-	private Paint realPaint;
-
-    private PdfGraphics2D() {
-        dg2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
-        setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
-    }
-    
-    /**
-     * Constructor for PDFGraphics2D.
-     *
-     */
-    PdfGraphics2D(PdfContentByte cb, float width, float height, FontMapper fontMapper, boolean onlyShapes, boolean convertImagesToJPEG, float quality) {
-        super();
-        dg2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
-        setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
-        try {
-            Class.forName("com.sun.image.codec.jpeg.JPEGCodec");
-        }
-        catch (Throwable t) {
-            convertImagesToJPEG = false;
-        }
-        this.convertImagesToJPEG = convertImagesToJPEG;
-        this.jpegQuality = quality;
-        this.onlyShapes = onlyShapes;
-        this.transform = new AffineTransform();
-        this.baseFonts = new HashMap();
-        if (!onlyShapes) {
-            this.fontMapper = fontMapper;
-            if (this.fontMapper == null)
-                this.fontMapper = new DefaultFontMapper();
-        }
-        paint = Color.black;
-        background = Color.white;
-        setFont(new Font("sanserif", Font.PLAIN, 12));
-        this.cb = cb;
-        cb.saveState();
-        this.width = width;
-        this.height = height;
-        clip = new Area(new Rectangle2D.Float(0, 0, width, height));
-        clip(clip);
-        originalStroke = stroke = oldStroke = strokeOne;
-        setStrokeDiff(stroke, null);
-        cb.saveState();
-    }
-    
-    /**
-     * @see Graphics2D#draw(Shape)
-     */
-    public void draw(Shape s) {
-        followPath(s, STROKE);
-    }
-    
-    /**
-     * @see Graphics2D#drawImage(Image, AffineTransform, ImageObserver)
-     */
-    public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs) {
-        return drawImage(img, null, xform, null, obs);
-    }
-    
-    /**
-     * @see Graphics2D#drawImage(BufferedImage, BufferedImageOp, int, int)
-     */
-    public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y) {
-        BufferedImage result = img;
-        if (op != null) {
-            result = op.createCompatibleDestImage(img, img.getColorModel());
-            result = op.filter(img, result);
-        }
-        drawImage(result, x, y, null);
-    }
-    
-    /**
-     * @see Graphics2D#drawRenderedImage(RenderedImage, AffineTransform)
-     */
-    public void drawRenderedImage(RenderedImage img, AffineTransform xform) {
-        BufferedImage image = null;
-        if (img instanceof BufferedImage) {
-            image = (BufferedImage)img;
-        } else {
-            ColorModel cm = img.getColorModel();
-            int width = img.getWidth();
-            int height = img.getHeight();
-            WritableRaster raster = cm.createCompatibleWritableRaster(width, height);
-            boolean isAlphaPremultiplied = cm.isAlphaPremultiplied();
-            Hashtable properties = new Hashtable();
-            String[] keys = img.getPropertyNames();
-            if (keys!=null) {
-                for (int i = 0; i < keys.length; i++) {
-                    properties.put(keys[i], img.getProperty(keys[i]));
-                }
-            }
-            BufferedImage result = new BufferedImage(cm, raster, isAlphaPremultiplied, properties);
-            img.copyData(raster);
-            image=result;
-        }
-        drawImage(image, xform, null);
-    }
-    
-    /**
-     * @see Graphics2D#drawRenderableImage(RenderableImage, AffineTransform)
-     */
-    public void drawRenderableImage(RenderableImage img, AffineTransform xform) {
-        drawRenderedImage(img.createDefaultRendering(), xform);
-    }
-    
-    /**
-     * @see Graphics#drawString(String, int, int)
-     */
-    public void drawString(String s, int x, int y) {
-        drawString(s, (float)x, (float)y);
-    }
-    
-    /**
-     * Calculates position and/or stroke thickness depending on the font size
-     * @param d value to be converted
-     * @param i font size
-     * @return position and/or stroke thickness depending on the font size
-     */
-    public static double asPoints(double d, int i) {
-        return (d * (double)i) / (double)AFM_DIVISOR;
-    }
-    /**
-     * This routine goes through the attributes and sets the font
-     * before calling the actual string drawing routine
-     * @param iter
-     */
-    protected void doAttributes(AttributedCharacterIterator iter) {
-        underline = false;
-        Set set = iter.getAttributes().keySet();
-        for(Iterator iterator = set.iterator(); iterator.hasNext();) {
-            AttributedCharacterIterator.Attribute attribute = (AttributedCharacterIterator.Attribute)iterator.next();
-            if (!(attribute instanceof TextAttribute))
-                continue;
-            TextAttribute textattribute = (TextAttribute)attribute;
-            if(textattribute.equals(TextAttribute.FONT)) {
-                Font font = (Font)iter.getAttributes().get(textattribute);
-                setFont(font);
-            }
-            else if(textattribute.equals(TextAttribute.UNDERLINE)) {
-                if(iter.getAttributes().get(textattribute) == TextAttribute.UNDERLINE_ON)
-                    underline = true;
-            }
-            else if(textattribute.equals(TextAttribute.SIZE)) {
-                Object obj = iter.getAttributes().get(textattribute);
-                if(obj instanceof Integer) {
-                    int i = ((Integer)obj).intValue();
-                    setFont(getFont().deriveFont(getFont().getStyle(), i));
-                }
-                else if(obj instanceof Float) {
-                    float f = ((Float)obj).floatValue();
-                    setFont(getFont().deriveFont(getFont().getStyle(), f));
-                }
-            }
-            else if(textattribute.equals(TextAttribute.FOREGROUND)) {
-                setColor((Color) iter.getAttributes().get(textattribute));
-            }
-            else if(textattribute.equals(TextAttribute.FAMILY)) {
-              Font font = getFont();
-              Map fontAttributes = font.getAttributes();
-              fontAttributes.put(TextAttribute.FAMILY, iter.getAttributes().get(textattribute));
-              setFont(font.deriveFont(fontAttributes));
-            }
-            else if(textattribute.equals(TextAttribute.POSTURE)) {
-              Font font = getFont();
-              Map fontAttributes = font.getAttributes();
-              fontAttributes.put(TextAttribute.POSTURE, iter.getAttributes().get(textattribute));
-              setFont(font.deriveFont(fontAttributes)); 
-            }
-            else if(textattribute.equals(TextAttribute.WEIGHT)) {
-              Font font = getFont();
-              Map fontAttributes = font.getAttributes();
-              fontAttributes.put(TextAttribute.WEIGHT, iter.getAttributes().get(textattribute));
-              setFont(font.deriveFont(fontAttributes)); 
-            }
-        }
-    }
-
-    /**
-     * @see Graphics2D#drawString(String, float, float)
-     */
-    public void drawString(String s, float x, float y) {
-        if (s.length() == 0)
-            return;
-        setFillPaint();
-        if (onlyShapes) {
-            drawGlyphVector(this.font.layoutGlyphVector(getFontRenderContext(), s.toCharArray(), 0, s.length(), java.awt.Font.LAYOUT_LEFT_TO_RIGHT), x, y);
-//            Use the following line to compile in JDK 1.3    
-//            drawGlyphVector(this.font.createGlyphVector(getFontRenderContext(), s), x, y);
-        }
-        else {
-            AffineTransform at = getTransform();
-            AffineTransform at2 = getTransform();
-            at2.translate(x, y);
-            at2.concatenate(font.getTransform());
-            setTransform(at2);
-            AffineTransform inverse = this.normalizeMatrix();
-            AffineTransform flipper = AffineTransform.getScaleInstance(1,-1);
-            inverse.concatenate(flipper);
-            double[] mx = new double[6];
-            inverse.getMatrix(mx);
-            cb.beginText();
-            cb.setFontAndSize(baseFont, fontSize);
-            cb.setTextMatrix((float)mx[0], (float)mx[1], (float)mx[2], (float)mx[3], (float)mx[4], (float)mx[5]);
-            double width = 0;
-            if (font.getSize2D() > 0) {
-                float scale = 1000 / font.getSize2D();
-                width = font.deriveFont(AffineTransform.getScaleInstance(scale, scale)).getStringBounds(s, getFontRenderContext()).getWidth() / scale;
-            }
-            if (s.length() > 1) {
-                float adv = ((float)width - baseFont.getWidthPoint(s, fontSize)) / (s.length() - 1);
-                cb.setCharacterSpacing(adv);
-            }
-            cb.showText(s);
-            if (s.length() > 1) {
-                cb.setCharacterSpacing(0);
-            }
-            cb.endText();
-            setTransform(at);
-            if(underline)
-            {
-                // These two are supposed to be taken from the .AFM file
-                //int UnderlinePosition = -100;
-                int UnderlineThickness = 50;
-                //
-                double d = asPoints((double)UnderlineThickness, (int)fontSize);
-                setStroke(new BasicStroke((float)d));
-                y = (float)((double)(y) + asPoints((double)(UnderlineThickness), (int)fontSize));
-                Line2D line = new Line2D.Double((double)x, (double)y, (double)(width+x), (double)y);
-                draw(line);
-            }
-        }
-    }
-
-    /**
-     * @see Graphics#drawString(AttributedCharacterIterator, int, int)
-     */
-    public void drawString(AttributedCharacterIterator iterator, int x, int y) {
-        drawString(iterator, (float)x, (float)y);
-    }
-    
-    /**
-     * @see Graphics2D#drawString(AttributedCharacterIterator, float, float)
-     */
-    public void drawString(AttributedCharacterIterator iter, float x, float y) {
+public class PdfGraphics2D extends Graphics2D
+{
+
+  private static final int FILL = 1;
+  private static final int STROKE = 2;
+  private static final int CLIP = 3;
+  private BasicStroke strokeOne = new BasicStroke(1);
+
+  private static final AffineTransform IDENTITY = new AffineTransform();
+
+  private Font font;
+  private BaseFont baseFont;
+  private float fontSize;
+  private AffineTransform transform;
+  private Paint paint;
+  private Color background;
+  private float width;
+  private float height;
+
+  private Area clip;
+
+  private RenderingHints rhints = new RenderingHints(null);
+
+  private Stroke stroke;
+  private Stroke originalStroke;
+
+  private PdfContentByte cb;
+
+  /**
+   * Storage for BaseFont objects created.
+   */
+  private HashMap baseFonts;
+
+  private boolean disposeCalled = false;
+
+  private FontMapper fontMapper;
+
+  private ArrayList kids;
+
+  private PdfGraphics2D parent;
+
+  private Graphics2D dg2 = new BufferedImage(2, 2, BufferedImage.TYPE_INT_RGB).createGraphics();
+
+  private boolean onlyShapes = false;
+
+  private Stroke oldStroke;
+  private Paint paintFill;
+  private Paint paintStroke;
+
+  private MediaTracker mediaTracker;
+
+  // Added by Jurij Bilas
+  private boolean underline;          // indicates if the font style is underlined
+
+  private PdfGState[] fillGState = new PdfGState[256];
+  private PdfGState[] strokeGState = new PdfGState[256];
+  private int currentFillGState = 255;
+  private int currentStrokeGState = 255;
+
+  public static final int AFM_DIVISOR = 1000; // used to calculate coordinates
+
+  private boolean convertImagesToJPEG = false;
+  private float jpegQuality = .95f;
+
+  // Added by Alexej Suchov
+  private float alpha;
+
+  // Added by Alexej Suchov
+  private Composite composite;
+
+  // Added by Alexej Suchov
+  private Paint realPaint;
+
+  private PdfGraphics2D()
+  {
+    dg2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
+    setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
+  }
+
+  /**
+   * Constructor for PDFGraphics2D.
+   */
+  PdfGraphics2D(final PdfContentByte cb,
+                final float width,
+                final float height,
+                final FontMapper fontMapper,
+                final boolean onlyShapes,
+                boolean convertImagesToJPEG,
+                final float quality)
+  {
+    super();
+    dg2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
+    setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
+    try
+    {
+      Class.forName("com.sun.image.codec.jpeg.JPEGCodec");
+    }
+    catch (Throwable t)
+    {
+      convertImagesToJPEG = false;
+    }
+    this.convertImagesToJPEG = convertImagesToJPEG;
+    this.jpegQuality = quality;
+    this.onlyShapes = onlyShapes;
+    this.transform = new AffineTransform();
+    this.baseFonts = new HashMap();
+    if (!onlyShapes)
+    {
+      this.fontMapper = fontMapper;
+      if (this.fontMapper == null)
+      {
+        this.fontMapper = new DefaultFontMapper();
+      }
+    }
+    paint = Color.black;
+    background = Color.white;
+    setFont(new Font("sanserif", Font.PLAIN, 12));
+    this.cb = cb;
+    cb.saveState();
+    this.width = width;
+    this.height = height;
+    clip = new Area(new Rectangle2D.Float(0, 0, width, height));
+    clip(clip);
+    originalStroke = stroke = oldStroke = strokeOne;
+    setStrokeDiff(stroke, null);
+    cb.saveState();
+  }
+
+  /**
+   * @see Graphics2D#draw(Shape)
+   */
+  public void draw(final Shape s)
+  {
+    followPath(s, STROKE);
+  }
+
+  /**
+   * @see Graphics2D#drawImage(Image, AffineTransform, ImageObserver)
+   */
+  public boolean drawImage(final Image img, final AffineTransform xform, final ImageObserver obs)
+  {
+    return drawImage(img, null, xform, null, obs);
+  }
+
+  /**
+   * @see Graphics2D#drawImage(BufferedImage, BufferedImageOp, int, int)
+   */
+  public void drawImage(final BufferedImage img, final BufferedImageOp op, final int x, final int y)
+  {
+    BufferedImage result = img;
+    if (op != null)
+    {
+      result = op.createCompatibleDestImage(img, img.getColorModel());
+      result = op.filter(img, result);
+    }
+    drawImage(result, x, y, null);
+  }
+
+  /**
+   * @noinspection UseOfObsoleteCollectionType
+   * @see Graphics2D#drawRenderedImage(RenderedImage, AffineTransform)
+   */
+  public void drawRenderedImage(final RenderedImage img, final AffineTransform xform)
+  {
+    final BufferedImage image;
+    if (img instanceof BufferedImage)
+    {
+      image = (BufferedImage) img;
+    }
+    else
+    {
+      final ColorModel cm = img.getColorModel();
+      final int width = img.getWidth();
+      final int height = img.getHeight();
+      final WritableRaster raster = cm.createCompatibleWritableRaster(width, height);
+      final boolean isAlphaPremultiplied = cm.isAlphaPremultiplied();
+      final Hashtable properties = new Hashtable();
+      final String[] keys = img.getPropertyNames();
+      if (keys != null)
+      {
+        for (int i = 0; i < keys.length; i++)
+        {
+          properties.put(keys[i], img.getProperty(keys[i]));
+        }
+      }
+      final BufferedImage result = new BufferedImage(cm, raster, isAlphaPremultiplied, properties);
+      img.copyData(raster);
+      image = result;
+    }
+    drawImage(image, xform, null);
+  }
+
+  /**
+   * @see Graphics2D#drawRenderableImage(RenderableImage, AffineTransform)
+   */
+  public void drawRenderableImage(final RenderableImage img, final AffineTransform xform)
+  {
+    drawRenderedImage(img.createDefaultRendering(), xform);
+  }
+
+  /**
+   * @see Graphics#drawString(String, int, int)
+   */
+  public void drawString(final String s, final int x, final int y)
+  {
+    drawString(s, (float) x, (float) y);
+  }
+
+  /**
+   * Calculates position and/or stroke thickness depending on the font size
+   *
+   * @param d value to be converted
+   * @param i font size
+   * @return position and/or stroke thickness depending on the font size
+   */
+  private static double asPoints(final double d, final int i)
+  {
+    return (d * (double) i) / (double) AFM_DIVISOR;
+  }
+
+  /**
+   * This routine goes through the attributes and sets the font before calling the actual string drawing routine
+   *
+   * @param iter
+   */
+  private void doAttributes(final AttributedCharacterIterator iter)
+  {
+    underline = false;
+    final Set set = iter.getAttributes().keySet();
+    for (Iterator iterator = set.iterator(); iterator.hasNext();)
+    {
+      final AttributedCharacterIterator.Attribute attribute = (AttributedCharacterIterator.Attribute) iterator.next();
+      if (!(attribute instanceof TextAttribute))
+      {
+        continue;
+      }
+      final TextAttribute textattribute = (TextAttribute) attribute;
+      if (textattribute.equals(TextAttribute.FONT))
+      {
+        final Font font = (Font) iter.getAttributes().get(textattribute);
+        setFont(font);
+      }
+      else if (textattribute.equals(TextAttribute.UNDERLINE))
+      {
+        if (iter.getAttributes().get(textattribute) == TextAttribute.UNDERLINE_ON)
+        {
+          underline = true;
+        }
+      }
+      else if (textattribute.equals(TextAttribute.SIZE))
+      {
+        final Object obj = iter.getAttributes().get(textattribute);
+        if (obj instanceof Integer)
+        {
+          final int i = ((Integer) obj).intValue();
+          setFont(getFont().deriveFont(getFont().getStyle(), i));
+        }
+        else if (obj instanceof Float)
+        {
+          final float f = ((Float) obj).floatValue();
+          setFont(getFont().deriveFont(getFont().getStyle(), f));
+        }
+      }
+      else if (textattribute.equals(TextAttribute.FOREGROUND))
+      {
+        setColor((Color) iter.getAttributes().get(textattribute));
+      }
+      else if (textattribute.equals(TextAttribute.FAMILY))
+      {
+        final Font font = getFont();
+        final Map fontAttributes = font.getAttributes();
+        fontAttributes.put(TextAttribute.FAMILY, iter.getAttributes().get(textattribute));
+        setFont(font.deriveFont(fontAttributes));
+      }
+      else if (textattribute.equals(TextAttribute.POSTURE))
+      {
+        final Font font = getFont();
+        final Map fontAttributes = font.getAttributes();
+        fontAttributes.put(TextAttribute.POSTURE, iter.getAttributes().get(textattribute));
+        setFont(font.deriveFont(fontAttributes));
+      }
+      else if (textattribute.equals(TextAttribute.WEIGHT))
+      {
+        final Font font = getFont();
+        final Map fontAttributes = font.getAttributes();
+        fontAttributes.put(TextAttribute.WEIGHT, iter.getAttributes().get(textattribute));
+        setFont(font.deriveFont(fontAttributes));
+      }
+    }
+  }
+
+  /**
+   * @see Graphics2D#drawString(String, float, float)
+   */
+  public void drawString(final String s, final float x, float y)
+  {
+    if (s.length() == 0)
+    {
+      return;
+    }
+    setFillPaint();
+    if (onlyShapes)
+    {
+//            drawGlyphVector(this.font.layoutGlyphVector(getFontRenderContext(), s.toCharArray(), 0, s.length(), java.awt.Font.LAYOUT_LEFT_TO_RIGHT), x, y);
+//            Use the following line to compile in JDK 1.3
+      // Patched: JDK 1.2 compatiblity ..
+      drawGlyphVector(this.font.createGlyphVector(getFontRenderContext(), s), x, y);
+    }
+    else
+    {
+      final AffineTransform at = getTransform();
+      final AffineTransform at2 = getTransform();
+      at2.translate(x, y);
+      at2.concatenate(font.getTransform());
+      setTransform(at2);
+      final AffineTransform inverse = this.normalizeMatrix();
+      final AffineTransform flipper = AffineTransform.getScaleInstance(1, -1);
+      inverse.concatenate(flipper);
+      final double[] mx = new double[6];
+      inverse.getMatrix(mx);
+      cb.beginText();
+      cb.setFontAndSize(baseFont, fontSize);
+      cb.setTextMatrix((float) mx[0], (float) mx[1], (float) mx[2], (float) mx[3], (float) mx[4], (float) mx[5]);
+      double width = 0;
+      if (font.getSize2D() > 0)
+      {
+        final float scale = 1000 / font.getSize2D();
+        width = font.deriveFont(AffineTransform.getScaleInstance(scale, scale)).getStringBounds(s, getFontRenderContext()).getWidth() / scale;
+      }
+      if (s.length() > 1)
+      {
+        final float adv = ((float) width - baseFont.getWidthPoint(s, fontSize)) / (s.length() - 1);
+        cb.setCharacterSpacing(adv);
+      }
+      cb.showText(s);
+      if (s.length() > 1)
+      {
+        cb.setCharacterSpacing(0);
+      }
+      cb.endText();
+      setTransform(at);
+      if (underline)
+      {
+        // These two are supposed to be taken from the .AFM file
+        //int UnderlinePosition = -100;
+        final int UnderlineThickness = 50;
+        //
+        final double d = asPoints((double) UnderlineThickness, (int) fontSize);
+        setStroke(new BasicStroke((float) d));
+        y = (float) ((double) (y) + asPoints((double) (UnderlineThickness), (int) fontSize));
+        final Line2D line = new Line2D.Double((double) x, (double) y, (width + x), (double) y);
+        draw(line);
+      }
+    }
+  }
+
+  /**
+   * @see Graphics#drawString(AttributedCharacterIterator, int, int)
+   */
+  public void drawString(final AttributedCharacterIterator iterator, final int x, final int y)
+  {
+    drawString(iterator, (float) x, (float) y);
+  }
+
+  /**
+   * @see Graphics2D#drawString(AttributedCharacterIterator, float, float)
+   */
+  public void drawString(final AttributedCharacterIterator iter, float x, final float y)
+  {
 /*
         StringBuffer sb = new StringBuffer();
         for(char c = iter.first(); c != AttributedCharacterIterator.DONE; c = iter.next()) {
@@ -419,1105 +476,1422 @@
         }
         drawString(sb.toString(),x,y);
 */
-        StringBuffer stringbuffer = new StringBuffer(iter.getEndIndex());
-        for(char c = iter.first(); c != '\uFFFF'; c = iter.next())
+    final StringBuffer stringbuffer = new StringBuffer(iter.getEndIndex());
+    for (char c = iter.first(); c != '\uFFFF'; c = iter.next())
+    {
+      if (iter.getIndex() == iter.getRunStart())
+      {
+        if (stringbuffer.length() > 0)
+        {
+          drawString(stringbuffer.toString(), x, y);
+          final FontMetrics fontmetrics = getFontMetrics();
+          x = (float) ((double) x + fontmetrics.getStringBounds(stringbuffer.toString(), this).getWidth());
+          stringbuffer.delete(0, stringbuffer.length());
+        }
+        doAttributes(iter);
+      }
+      stringbuffer.append(c);
+    }
+
+    drawString(stringbuffer.toString(), x, y);
+    underline = false;
+  }
+
+  /**
+   * @see Graphics2D#drawGlyphVector(GlyphVector, float, float)
+   */
+  public void drawGlyphVector(final GlyphVector g, final float x, final float y)
+  {
+    final Shape s = g.getOutline(x, y);
+    fill(s);
+  }
+
+  /**
+   * @see Graphics2D#fill(Shape)
+   */
+  public void fill(final Shape s)
+  {
+    followPath(s, FILL);
+  }
+
+  /**
+   * @see Graphics2D#hit(Rectangle, Shape, boolean)
+   */
+  public boolean hit(final Rectangle rect, Shape s, final boolean onStroke)
+  {
+    if (onStroke)
+    {
+      s = stroke.createStrokedShape(s);
+    }
+    s = transform.createTransformedShape(s);
+    final Area area = new Area(s);
+    if (clip != null)
+    {
+      area.intersect(clip);
+    }
+    return area.intersects(rect.x, rect.y, rect.width, rect.height);
+  }
+
+  /**
+   * @see Graphics2D#getDeviceConfiguration()
+   */
+  public GraphicsConfiguration getDeviceConfiguration()
+  {
+    return dg2.getDeviceConfiguration();
+  }
+
+  /**
+   * Method contributed by Alexej Suchov
+   *
+   * @see Graphics2D#setComposite(Composite)
+   */
+  public void setComposite(final Composite comp)
+  {
+
+    if (comp instanceof AlphaComposite)
+    {
+
+      final AlphaComposite composite = (AlphaComposite) comp;
+
+      if (composite.getRule() == 3)
+      {
+
+        alpha = composite.getAlpha();
+        this.composite = composite;
+
+        if (realPaint != null && (realPaint instanceof Color))
+        {
+
+          final Color c = (Color) realPaint;
+          paint = new Color(c.getRed(), c.getGreen(), c.getBlue(),
+              (int) ((float) c.getAlpha() * alpha));
+        }
+        return;
+      }
+    }
+
+    this.composite = comp;
+    alpha = 1.0F;
+
+  }
+
+  /**
+   * Method contributed by Alexej Suchov
+   *
+   * @see Graphics2D#setPaint(Paint)
+   */
+  public void setPaint(final Paint paint)
+  {
+    if (paint == null)
+    {
+      return;
+    }
+    this.paint = paint;
+    realPaint = paint;
+
+    if ((composite instanceof AlphaComposite) && (paint instanceof Color))
+    {
+
+      final AlphaComposite co = (AlphaComposite) composite;
+
+      if (co.getRule() == 3)
+      {
+        final Color c = (Color) paint;
+        this.paint = new Color(c.getRed(), c.getGreen(), c.getBlue(), (int) ((float) c.getAlpha() * alpha));
+        realPaint = paint;
+      }
+    }
+
+  }
+
+  private Stroke transformStroke(final Stroke stroke)
+  {
+    if (!(stroke instanceof BasicStroke))
+    {
+      return stroke;
+    }
+    final BasicStroke st = (BasicStroke) stroke;
+    final float scale = (float) Math.sqrt(Math.abs(transform.getDeterminant()));
+    final float[] dash = st.getDashArray();
+    if (dash != null)
+    {
+      for (int k = 0; k < dash.length; ++k)
+      {
+        dash[k] *= scale;
+      }
+    }
+    return new BasicStroke(st.getLineWidth() * scale, st.getEndCap(), st.getLineJoin(), st.getMiterLimit(), dash, st.getDashPhase() * scale);
+  }
+
+  private void setStrokeDiff(final Stroke newStroke, final Stroke oldStroke)
+  {
+    if (newStroke == oldStroke)
+    {
+      return;
+    }
+    if (!(newStroke instanceof BasicStroke))
+    {
+      return;
+    }
+    final BasicStroke nStroke = (BasicStroke) newStroke;
+    final boolean oldOk = (oldStroke instanceof BasicStroke);
+    BasicStroke oStroke = null;
+    if (oldOk)
+    {
+      oStroke = (BasicStroke) oldStroke;
+    }
+    if (!oldOk || nStroke.getLineWidth() != oStroke.getLineWidth())
+    {
+      cb.setLineWidth(nStroke.getLineWidth());
+    }
+    if (!oldOk || nStroke.getEndCap() != oStroke.getEndCap())
+    {
+      switch (nStroke.getEndCap())
+      {
+        case BasicStroke.CAP_BUTT:
+          cb.setLineCap(0);
+          break;
+        case BasicStroke.CAP_SQUARE:
+          cb.setLineCap(2);
+          break;
+        default:
+          cb.setLineCap(1);
+      }
+    }
+    if (!oldOk || nStroke.getLineJoin() != oStroke.getLineJoin())
+    {
+      switch (nStroke.getLineJoin())
+      {
+        case BasicStroke.JOIN_MITER:
+          cb.setLineJoin(0);
+          break;
+        case BasicStroke.JOIN_BEVEL:
+          cb.setLineJoin(2);
+          break;
+        default:
+          cb.setLineJoin(1);
+      }
+    }
+    if (!oldOk || nStroke.getMiterLimit() != oStroke.getMiterLimit())
+    {
+      cb.setMiterLimit(nStroke.getMiterLimit());
+    }
+    final boolean makeDash;
+    if (oldOk)
+    {
+      if (nStroke.getDashArray() != null)
+      {
+        if (nStroke.getDashPhase() != oStroke.getDashPhase())
         {
-            if(iter.getIndex() == iter.getRunStart())
-            {
-                if(stringbuffer.length() > 0)
-                {
-                    drawString(stringbuffer.toString(), x, y);
-                    FontMetrics fontmetrics = getFontMetrics();
-                    x = (float)((double)x + fontmetrics.getStringBounds(stringbuffer.toString(), this).getWidth());
-                    stringbuffer.delete(0, stringbuffer.length());
-                }
-                doAttributes(iter);
-            }
-            stringbuffer.append(c);
-        }
-        
-        drawString(stringbuffer.toString(), x, y);
-        underline = false;
-    }
-    
-    /**
-     * @see Graphics2D#drawGlyphVector(GlyphVector, float, float)
-     */
-    public void drawGlyphVector(GlyphVector g, float x, float y) {
-        Shape s = g.getOutline(x, y);
-        fill(s);
-    }
-    
-    /**
-     * @see Graphics2D#fill(Shape)
-     */
-    public void fill(Shape s) {
+          makeDash = true;
+        }
+        else if (!Arrays.equals(nStroke.getDashArray(), oStroke.getDashArray()))
+        {
+          makeDash = true;
+        }
+        else
+        {
+          makeDash = false;
+        }
+      }
+      else if (oStroke.getDashArray() != null)
+      {
+        makeDash = true;
+      }
+      else
+      {
+        makeDash = false;
+      }
+    }
+    else
+    {
+      makeDash = true;
+    }
+    if (makeDash)
+    {
+      final float[] dash = nStroke.getDashArray();
+      if (dash == null)
+      {
+        cb.setLiteral("[]0 d\n");
+      }
+      else
+      {
+        cb.setLiteral('[');
+        final int lim = dash.length;
+        for (int k = 0; k < lim; ++k)
+        {
+          cb.setLiteral(dash[k]);
+          cb.setLiteral(' ');
+        }
+        cb.setLiteral(']');
+        cb.setLiteral(nStroke.getDashPhase());
+        cb.setLiteral(" d\n");
+      }
+    }
+  }
+
+  /**
+   * @see Graphics2D#setStroke(Stroke)
+   */
+  public void setStroke(final Stroke s)
+  {
+    originalStroke = s;
+    this.stroke = transformStroke(s);
+  }
+
+
+  /**
+   * Sets a rendering hint
+   *
+   * @param arg0
+   * @param arg1
+   */
+  public void setRenderingHint(final RenderingHints.Key arg0, final Object arg1)
+  {
+    rhints.put(arg0, arg1);
+  }
+
+  /**
+   * @param arg0 a key
+   * @return the rendering hint
+   */
+  public Object getRenderingHint(final RenderingHints.Key arg0)
+  {
+    return rhints.get(arg0);
+  }
+
+  /**
+   * @see Graphics2D#setRenderingHints(Map)
+   */
+  public void setRenderingHints(final Map hints)
+  {
+    rhints.clear();
+    rhints.putAll(hints);
+  }
+
+  /**
+   * @see Graphics2D#addRenderingHints(Map)
+   */
+  public void addRenderingHints(final Map hints)
+  {
+    rhints.putAll(hints);
+  }
+
+  /**
+   * @see Graphics2D#getRenderingHints()
+   */
+  public RenderingHints getRenderingHints()
+  {
+    return rhints;
+  }
+
+  /**
+   * @see Graphics#translate(int, int)
+   */
+  public void translate(final int x, final int y)
+  {
+    translate((double) x, (double) y);
+  }
+
+  /**
+   * @see Graphics2D#translate(double, double)
+   */
+  public void translate(final double tx, final double ty)
+  {
+    transform.translate(tx, ty);
+  }
+
+  /**
+   * @see Graphics2D#rotate(double)
+   */
+  public void rotate(final double theta)
+  {
+    transform.rotate(theta);
+  }
+
+  /**
+   * @see Graphics2D#rotate(double, double, double)
+   */
+  public void rotate(final double theta, final double x, final double y)
+  {
+    transform.rotate(theta, x, y);
+  }
+
+  /**
+   * @see Graphics2D#scale(double, double)
+   */
+  public void scale(final double sx, final double sy)
+  {
+    transform.scale(sx, sy);
+    this.stroke = transformStroke(originalStroke);
+  }
+
+  /**
+   * @see Graphics2D#shear(double, double)
+   */
+  public void shear(final double shx, final double shy)
+  {
+    transform.shear(shx, shy);
+  }
+
+  /**
+   * @see Graphics2D#transform(AffineTransform)
+   */
+  public void transform(final AffineTransform tx)
+  {
+    transform.concatenate(tx);
+    this.stroke = transformStroke(originalStroke);
+  }
+
+  /**
+   * @see Graphics2D#setTransform(AffineTransform)
+   */
+  public void setTransform(final AffineTransform t)
+  {
+    transform = new AffineTransform(t);
+    this.stroke = transformStroke(originalStroke);
+  }
+
+  /**
+   * @see Graphics2D#getTransform()
+   */
+  public AffineTransform getTransform()
+  {
+    return new AffineTransform(transform);
+  }
+
+  /**
+   * Method contributed by Alexej Suchov
+   *
+   * @see Graphics2D#getPaint()
+   */
+  public Paint getPaint()
+  {
+    if (realPaint != null)
+    {
+      return realPaint;
+    }
+    else
+    {
+      return paint;
+    }
+  }
+
+  /**
+   * @see Graphics2D#getComposite()
+   */
+  public Composite getComposite()
+  {
+    return null;
+  }
+
+  /**
+   * @see Graphics2D#setBackground(Color)
+   */
+  public void setBackground(final Color color)
+  {
+    background = color;
+  }
+
+  /**
+   * @see Graphics2D#getBackground()
+   */
+  public Color getBackground()
+  {
+    return background;
+  }
+
+  /**
+   * @see Graphics2D#getStroke()
+   */
+  public Stroke getStroke()
+  {
+    return originalStroke;
+  }
+
+
+  /**
+   * @see Graphics2D#getFontRenderContext()
+   */
+  public FontRenderContext getFontRenderContext()
+  {
+    final boolean antialias = RenderingHints.VALUE_TEXT_ANTIALIAS_ON.equals(getRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING));
+    final boolean fractions = RenderingHints.VALUE_FRACTIONALMETRICS_ON.equals(getRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS));
+    return new FontRenderContext(new AffineTransform(), antialias, fractions);
+  }
+
+  /**
+   * @see Graphics#create()
+   */
+  public Graphics create()
+  {
+    final PdfGraphics2D g2 = new PdfGraphics2D();
+    g2.onlyShapes = this.onlyShapes;
+    g2.transform = new AffineTransform(this.transform);
+    g2.baseFonts = this.baseFonts;
+    g2.fontMapper = this.fontMapper;
+    g2.paint = this.paint;
+    g2.fillGState = this.fillGState;
+    g2.strokeGState = this.strokeGState;
+    g2.background = this.background;
+    g2.mediaTracker = this.mediaTracker;
+    g2.convertImagesToJPEG = this.convertImagesToJPEG;
+    g2.jpegQuality = this.jpegQuality;
+    g2.setFont(this.font);
+    g2.cb = this.cb.getDuplicate();
+    g2.cb.saveState();
+    g2.width = this.width;
+    g2.height = this.height;
+    g2.followPath(new Area(new Rectangle2D.Float(0, 0, width, height)), CLIP);
+    if (this.clip != null)
+    {
+      g2.clip = new Area(this.clip);
+    }
+    g2.stroke = stroke;
+    g2.originalStroke = originalStroke;
+    g2.strokeOne = (BasicStroke) g2.transformStroke(g2.strokeOne);
+    g2.oldStroke = g2.strokeOne;
+    g2.setStrokeDiff(g2.oldStroke, null);
+    g2.cb.saveState();
+    if (g2.clip != null)
+    {
+      g2.followPath(g2.clip, CLIP);
+    }
+    g2.parent = this;
+    if (this.kids == null)
+    {
+      this.kids = new ArrayList();
+    }
+    // This is disgusting. You really cant override the buffer on the fixed position. The way the dispose() code
+    // handles the cleanup, this will create a huge mess ...
+    // this.kids.add(new Integer(cb.getInternalBuffer().size()));
+    this.kids.add(g2);
+    return g2;
+  }
+
+  public PdfContentByte getContent()
+  {
+    return this.cb;
+  }
+
+  /**
+   * @see Graphics#getColor()
+   */
+  public Color getColor()
+  {
+    if (paint instanceof Color)
+    {
+      return (Color) paint;
+    }
+    else
+    {
+      return Color.black;
+    }
+  }
+
+  /**
+   * @see Graphics#setColor(Color)
+   */
+  public void setColor(final Color color)
+  {
+    setPaint(color);
+  }
+
+  /**
+   * @see Graphics#setPaintMode()
+   */
+  public void setPaintMode()
+  {
+  }
+
+  /**
+   * @see Graphics#setXORMode(Color)
+   */
+  public void setXORMode(final Color c1)
+  {
+
+  }
+
+  /**
+   * @see Graphics#getFont()
+   */
+  public Font getFont()
+  {
+    return font;
+  }
+
+  /**
+   * @see Graphics#setFont(Font)
+   */
+  /**
+   * Sets the current font.
+   */
+  public void setFont(final Font f)
+  {
+    if (f == null)
+    {
+      return;
+    }
+    if (onlyShapes)
+    {
+      font = f;
+      return;
+    }
+    if (f == font)
+    {
+      return;
+    }
+    font = f;
+    fontSize = f.getSize2D();
+    baseFont = getCachedBaseFont(f);
+  }
+
+  private BaseFont getCachedBaseFont(final Font f)
+  {
+    synchronized (baseFonts)
+    {
+      BaseFont bf = (BaseFont) baseFonts.get(f.getFontName());
+      if (bf == null)
+      {
+        bf = fontMapper.awtToPdf(f);
+        baseFonts.put(f.getFontName(), bf);
+      }
+      return bf;
+    }
+  }
+
+  /**
+   * @see Graphics#getFontMetrics(Font)
+   */
+  public FontMetrics getFontMetrics(final Font f)
+  {
+    return dg2.getFontMetrics(f);
+  }
+
+  /**
+   * @see Graphics#getClipBounds()
+   */
+  public Rectangle getClipBounds()
+  {
+    if (clip == null)
+    {
+      return null;
+    }
+    return getClip().getBounds();
+  }
+
+  /**
+   * @see Graphics#clipRect(int, int, int, int)
+   */
+  public void clipRect(final int x, final int y, final int width, final int height)
+  {
+    final Rectangle2D rect = new Rectangle2D.Double(x, y, width, height);
+    clip(rect);
+  }
+
+  /**
+   * @see Graphics#setClip(int, int, int, int)
+   */
+  public void setClip(final int x, final int y, final int width, final int height)
+  {
+    final Rectangle2D rect = new Rectangle2D.Double(x, y, width, height);
+    setClip(rect);
+  }
+
+  /**
+   * @see Graphics2D#clip(Shape)
+   */
+  public void clip(Shape s)
+  {
+    if (s == null)
+    {
+      setClip(null);
+      return;
+    }
+    s = transform.createTransformedShape(s);
+    if (clip == null)
+    {
+      clip = new Area(s);
+    }
+    else
+    {
+      clip.intersect(new Area(s));
+    }
+    followPath(s, CLIP);
+  }
+
+  /**
+   * @see Graphics#getClip()
+   */
+  public Shape getClip()
+  {
+    try
+    {
+      return transform.createInverse().createTransformedShape(clip);
+    }
+    catch (NoninvertibleTransformException e)
+    {
+      return null;
+    }
+  }
+
+  /**
+   * @see Graphics#setClip(Shape)
+   */
+  public void setClip(Shape s)
+  {
+    cb.restoreState();
+    cb.saveState();
+    if (s != null)
+    {
+      s = transform.createTransformedShape(s);
+    }
+    if (s == null)
+    {
+      clip = null;
+    }
+    else
+    {
+      clip = new Area(s);
+      followPath(s, CLIP);
+    }
+    paintFill = paintStroke = null;
+    currentFillGState = currentStrokeGState = 255;
+    oldStroke = strokeOne;
+  }
+
+  /**
+   * @see Graphics#copyArea(int, int, int, int, int, int)
+   */
+  public void copyArea(final int x, final int y, final int width, final int height, final int dx, final int dy)
+  {
+
+  }
+
+  /**
+   * @see Graphics#drawLine(int, int, int, int)
+   */
+  public void drawLine(final int x1, final int y1, final int x2, final int y2)
+  {
+    final Line2D line = new Line2D.Double((double) x1, (double) y1, (double) x2, (double) y2);
+    draw(line);
+  }
+
+  /**
+   * @see Graphics#fillRect(int, int, int, int)
+   */
+  public void drawRect(final int x, final int y, final int width, final int height)
+  {
+    draw(new Rectangle(x, y, width, height));
+  }
+
+  /**
+   * @see Graphics#fillRect(int, int, int, int)
+   */
+  public void fillRect(final int x, final int y, final int width, final int height)
+  {
+    fill(new Rectangle(x, y, width, height));
+  }
+
+  /**
+   * @see Graphics#clearRect(int, int, int, int)
+   */
+  public void clearRect(final int x, final int y, final int width, final int height)
+  {
+    final Paint temp = paint;
+    setPaint(background);
+    fillRect(x, y, width, height);
+    setPaint(temp);
+  }
+
+  /**
+   * @see Graphics#drawRoundRect(int, int, int, int, int, int)
+   */
+  public void drawRoundRect(final int x,
+                            final int y,
+                            final int width,
+                            final int height,
+                            final int arcWidth,
+                            final int arcHeight)
+  {
+    final RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, arcWidth, arcHeight);
+    draw(rect);
+  }
+
+  /**
+   * @see Graphics#fillRoundRect(int, int, int, int, int, int)
+   */
+  public void fillRoundRect(final int x,
+                            final int y,
+                            final int width,
+                            final int height,
+                            final int arcWidth,
+                            final int arcHeight)
+  {
+    final RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, arcWidth, arcHeight);
+    fill(rect);
+  }
+
+  /**
+   * @see Graphics#drawOval(int, int, int, int)
+   */
+  public void drawOval(final int x, final int y, final int width, final int height)
+  {
+    final Ellipse2D oval = new Ellipse2D.Float((float) x, (float) y, (float) width, (float) height);
+    draw(oval);
+  }
+
+  /**
+   * @see Graphics#fillOval(int, int, int, int)
+   */
+  public void fillOval(final int x, final int y, final int width, final int height)
+  {
+    final Ellipse2D oval = new Ellipse2D.Float((float) x, (float) y, (float) width, (float) height);
+    fill(oval);
+  }
+
+  /**
+   * @see Graphics#drawArc(int, int, int, int, int, int)
+   */
+  public void drawArc(final int x,
+                      final int y,
+                      final int width,
+                      final int height,
+                      final int startAngle,
+                      final int arcAngle)
+  {
+    final Arc2D arc = new Arc2D.Double(x, y, width, height, startAngle, arcAngle, Arc2D.OPEN);
+    draw(arc);
+
+  }
+
+  /**
+   * @see Graphics#fillArc(int, int, int, int, int, int)
+   */
+  public void fillArc(final int x,
+                      final int y,
+                      final int width,
+                      final int height,
+                      final int startAngle,
+                      final int arcAngle)
+  {
+    final Arc2D arc = new Arc2D.Double(x, y, width, height, startAngle, arcAngle, Arc2D.PIE);
+    fill(arc);
+  }
+
+  /**
+   * @see Graphics#drawPolyline(int[], int[], int)
+   */
+  public void drawPolyline(final int[] x, final int[] y, final int nPoints)
+  {
+    final Line2D line = new Line2D.Double(x[0], y[0], x[0], y[0]);
+    for (int i = 1; i < nPoints; i++)
+    {
+      line.setLine(line.getX2(), line.getY2(), x[i], y[i]);
+      draw(line);
+    }
+  }
+
+  /**
+   * @see Graphics#drawPolygon(int[], int[], int)
+   */
+  public void drawPolygon(final int[] xPoints, final int[] yPoints, final int nPoints)
+  {
+    final Polygon poly = new Polygon();
+    for (int i = 0; i < nPoints; i++)
+    {
+      poly.addPoint(xPoints[i], yPoints[i]);
+    }
+    draw(poly);
+  }
+
+  /**
+   * @see Graphics#fillPolygon(int[], int[], int)
+   */
+  public void fillPolygon(final int[] xPoints, final int[] yPoints, final int nPoints)
+  {
+    final Polygon poly = new Polygon();
+    for (int i = 0; i < nPoints; i++)
+    {
+      poly.addPoint(xPoints[i], yPoints[i]);
+    }
+    fill(poly);
+  }
+
+  /**
+   * @see Graphics#drawImage(Image, int, int, ImageObserver)
+   */
+  public boolean drawImage(final Image img, final int x, final int y, final ImageObserver observer)
+  {
+    return drawImage(img, x, y, null, observer);
+  }
+
+  /**
+   * @see Graphics#drawImage(Image, int, int, int, int, ImageObserver)
+   */
+  public boolean drawImage(final Image img,
+                           final int x,
+                           final int y,
+                           final int width,
+                           final int height,
+                           final ImageObserver observer)
+  {
+    return drawImage(img, x, y, width, height, null, observer);
+  }
+
+  /**
+   * @see Graphics#drawImage(Image, int, int, Color, ImageObserver)
+   */
+  public boolean drawImage(final Image img, final int x, final int y, final Color bgcolor, final ImageObserver observer)
+  {
+    waitForImage(img);
+    return drawImage(img, x, y, img.getWidth(observer), img.getHeight(observer), bgcolor, observer);
+  }
+
+  /**
+   * @see Graphics#drawImage(Image, int, int, int, int, Color, ImageObserver)
+   */
+  public boolean drawImage(final Image img,
+                           final int x,
+                           final int y,
+                           final int width,
+                           final int height,
+                           final Color bgcolor,
+                           final ImageObserver observer)
+  {
+    waitForImage(img);
+    final double scalex = width / (double) img.getWidth(observer);
+    final double scaley = height / (double) img.getHeight(observer);
+    final AffineTransform tx = AffineTransform.getTranslateInstance(x, y);
+    tx.scale(scalex, scaley);
+    return drawImage(img, null, tx, bgcolor, observer);
+  }
+
+  /**
+   * @see Graphics#drawImage(Image, int, int, int, int, int, int, int, int, ImageObserver)
+   */
+  public boolean drawImage(final Image img,
+                           final int dx1,
+                           final int dy1,
+                           final int dx2,
+                           final int dy2,
+                           final int sx1,
+                           final int sy1,
+                           final int sx2,
+                           final int sy2,
+                           final ImageObserver observer)
+  {
+    return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null, observer);
+  }
+
+  /**
+   * @see Graphics#drawImage(Image, int, int, int, int, int, int, int, int, Color, ImageObserver)
+   */
+  public boolean drawImage(final Image img,
+                           final int dx1,
+                           final int dy1,
+                           final int dx2,
+                           final int dy2,
+                           final int sx1,
+                           final int sy1,
+                           final int sx2,
+                           final int sy2,
+                           final Color bgcolor,
+                           final ImageObserver observer)
+  {
+    waitForImage(img);
+    final double dwidth = (double) dx2 - dx1;
+    final double dheight = (double) dy2 - dy1;
+    final double swidth = (double) sx2 - sx1;
+    final double sheight = (double) sy2 - sy1;
+
+    //if either width or height is 0, then there is nothing to draw
+    if (dwidth == 0 || dheight == 0 || swidth == 0 || sheight == 0)
+    {
+      return true;
+    }
+
+    final double scalex = dwidth / swidth;
+    final double scaley = dheight / sheight;
+
+    final double transx = sx1 * scalex;
+    final double transy = sy1 * scaley;
+    final AffineTransform tx = AffineTransform.getTranslateInstance(dx1 - transx, dy1 - transy);
+    tx.scale(scalex, scaley);
+
+    final BufferedImage mask = new BufferedImage(img.getWidth(observer), img.getHeight(observer), BufferedImage.TYPE_BYTE_BINARY);
+    final Graphics g = mask.getGraphics();
+    g.fillRect(sx1, sy1, (int) swidth, (int) sheight);
+    drawImage(img, mask, tx, null, observer);
+    g.dispose();
+    return true;
+  }
+
+  /**
+   * @see Graphics#dispose()
+   */
+  public void dispose()
+  {
+
+    if (!disposeCalled)
+    {
+      disposeCalled = true;
+      cb.restoreState();
+      cb.restoreState();
+      dg2.dispose();
+      dg2 = null;
+
+      for (int k = 0; k < kids.size(); ++k)
+      {
+        final PdfGraphics2D g2 = (PdfGraphics2D) kids.get(k);
+        if (g2.disposeCalled == false)
+        {
+          g2.dispose();
+        }
+      }
+
+      if (parent != null)
+      {
+        parent.cb.add(cb);
+        parent = null;
+      }
+    }
+  }
+
+//    private void internalDispose(ByteBuffer buf) {
+//        int last = 0;
+//
+//        final ByteBuffer buf2 = cb.getInternalBuffer();
+//
+//        for (int k = 0; k < kids.size(); k += 1) {
+////            final int pos = ((Integer)kids.get(k)).intValue();
+//            final PdfGraphics2D g2 = (PdfGraphics2D)kids.get(k + 1);
+//            g2.cb.restoreState();
+//            g2.cb.restoreState();
+//            buf.append(buf2.getBuffer(), last, pos - last);
+//            g2.dg2.dispose();
+//            g2.dg2 = null;
+//            g2.internalDispose(buf);
+//            last = pos;
+//        }
+//
+//        buf.append(buf2.getBuffer(), last, buf2.size() - last);
+//    }
+
+  ///////////////////////////////////////////////
+  //
+  //
+  //		implementation specific methods
+  //
+  //
+
+
+  private void followPath(Shape s, final int drawType)
+  {
+    if (s == null)
+    {
+      return;
+    }
+    if (drawType == STROKE)
+    {
+      if (!(stroke instanceof BasicStroke))
+      {
+        s = stroke.createStrokedShape(s);
         followPath(s, FILL);
+        return;
+      }
     }
-    
-    /**
-     * @see Graphics2D#hit(Rectangle, Shape, boolean)
-     */
-    public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
-        if (onStroke) {
-            s = stroke.createStrokedShape(s);
-        }
-        s = transform.createTransformedShape(s);
-        Area area = new Area(s);
-        if (clip != null)
-            area.intersect(clip);
-        return area.intersects(rect.x, rect.y, rect.width, rect.height);
-    }
-    
-    /**
-     * @see Graphics2D#getDeviceConfiguration()
-     */
-    public GraphicsConfiguration getDeviceConfiguration() {
-        return dg2.getDeviceConfiguration();
-    }
-    
-    /**
-	 * Method contributed by Alexej Suchov
-     * @see Graphics2D#setComposite(Composite)
-     */
-    public void setComposite(Composite comp) {
-        
-		if (comp instanceof AlphaComposite) {
-
-			AlphaComposite composite = (AlphaComposite) comp;
-
-			if (composite.getRule() == 3) {
-
-				alpha = composite.getAlpha();
-				this.composite = composite;
-
-				if (realPaint != null && (realPaint instanceof Color)) {
-
-					Color c = (Color) realPaint;
-					paint = new Color(c.getRed(), c.getGreen(), c.getBlue(),
-							(int) ((float) c.getAlpha() * alpha));
-				}
-				return;
-			}
-		}
-
-		this.composite = comp;
-		alpha = 1.0F;
-
-    }
-    
-    /**
-	 * Method contributed by Alexej Suchov
-     * @see Graphics2D#setPaint(Paint)
-     */
-    public void setPaint(Paint paint) {
-        if (paint == null)
-            return;
-        this.paint = paint;
-		realPaint = paint;
-
-		if ((composite instanceof AlphaComposite) && (paint instanceof Color)) {
-			
-			AlphaComposite co = (AlphaComposite) composite;
-			
-			if (co.getRule() == 3) {
-				Color c = (Color) paint;
-				this.paint = new Color(c.getRed(), c.getGreen(), c.getBlue(), (int) ((float) c.getAlpha() * alpha));
-				realPaint = paint;
-			}
-		}
-
-    }
-
-    private Stroke transformStroke(Stroke stroke) {
-        if (!(stroke instanceof BasicStroke))
-            return stroke;
-        BasicStroke st = (BasicStroke)stroke;
-        float scale = (float)Math.sqrt(Math.abs(transform.getDeterminant()));
-        float dash[] = st.getDashArray();
-        if (dash != null) {
-            for (int k = 0; k < dash.length; ++k)
-                dash[k] *= scale;
-        }
-        return new BasicStroke(st.getLineWidth() * scale, st.getEndCap(), st.getLineJoin(), st.getMiterLimit(), dash, st.getDashPhase() * scale);
-    }
-    
-    private void setStrokeDiff(Stroke newStroke, Stroke oldStroke) {
-        if (newStroke == oldStroke)
-            return;
-        if (!(newStroke instanceof BasicStroke))
-            return;
-        BasicStroke nStroke = (BasicStroke)newStroke;
-        boolean oldOk = (oldStroke instanceof BasicStroke);
-        BasicStroke oStroke = null;
-        if (oldOk)
-            oStroke = (BasicStroke)oldStroke;
-        if (!oldOk || nStroke.getLineWidth() != oStroke.getLineWidth())
-            cb.setLineWidth(nStroke.getLineWidth());
-        if (!oldOk || nStroke.getEndCap() != oStroke.getEndCap()) {
-            switch (nStroke.getEndCap()) {
-            case BasicStroke.CAP_BUTT:
-                cb.setLineCap(0);
-                break;
-            case BasicStroke.CAP_SQUARE:
-                cb.setLineCap(2);
-                break;
-            default:
-                cb.setLineCap(1);
-            }
-        }
-        if (!oldOk || nStroke.getLineJoin() != oStroke.getLineJoin()) {
-            switch (nStroke.getLineJoin()) {
-            case BasicStroke.JOIN_MITER:
-                cb.setLineJoin(0);
-                break;
-            case BasicStroke.JOIN_BEVEL:
-                cb.setLineJoin(2);
-                break;
-            default:
-                cb.setLineJoin(1);
-            }
-        }
-        if (!oldOk || nStroke.getMiterLimit() != oStroke.getMiterLimit())
-            cb.setMiterLimit(nStroke.getMiterLimit());
-        boolean makeDash;
-        if (oldOk) {
-            if (nStroke.getDashArray() != null) {
-                if (nStroke.getDashPhase() != oStroke.getDashPhase()) {
-                    makeDash = true;
-                }
-                else if (!java.util.Arrays.equals(nStroke.getDashArray(), oStroke.getDashArray())) {
-                    makeDash = true;
-                }
-                else
-                    makeDash = false;
-            }
-            else if (oStroke.getDashArray() != null) {
-                makeDash = true;
-            }
-            else
-                makeDash = false;
-        }
-        else {
-            makeDash = true;
-        }
-        if (makeDash) {
-            float dash[] = nStroke.getDashArray();
-            if (dash == null)
-                cb.setLiteral("[]0 d\n");
-            else {
-                cb.setLiteral('[');
-                int lim = dash.length;
-                for (int k = 0; k < lim; ++k) {
-                    cb.setLiteral(dash[k]);
-                    cb.setLiteral(' ');
-                }
-                cb.setLiteral(']');
-                cb.setLiteral(nStroke.getDashPhase());
-                cb.setLiteral(" d\n");
-            }
-        }
-    }
-    
-    /**
-     * @see Graphics2D#setStroke(Stroke)
-     */
-    public void setStroke(Stroke s) {
-        originalStroke = s;
-        this.stroke = transformStroke(s);
-    }
-    
-    
-    /**
-     * Sets a rendering hint
-     * @param arg0
-     * @param arg1
-     */
-    public void setRenderingHint(Key arg0, Object arg1) {
-        rhints.put(arg0, arg1);
-    }
-    
-    /**
-     * @param arg0 a key
-     * @return the rendering hint
-     */
-    public Object getRenderingHint(Key arg0) {
-        return rhints.get(arg0);
-    }
-    
-    /**
-     * @see Graphics2D#setRenderingHints(Map)
-     */
-    public void setRenderingHints(Map hints) {
-        rhints.clear();
-        rhints.putAll(hints);
-    }
-    
-    /**
-     * @see Graphics2D#addRenderingHints(Map)
-     */
-    public void addRenderingHints(Map hints) {
-        rhints.putAll(hints);
-    }
-    
-    /**
-     * @see Graphics2D#getRenderingHints()
-     */
-    public RenderingHints getRenderingHints() {
-        return rhints;
-    }
-    
-    /**
-     * @see Graphics#translate(int, int)
-     */
-    public void translate(int x, int y) {
-        translate((double)x, (double)y);
-    }
-    
-    /**
-     * @see Graphics2D#translate(double, double)
-     */
-    public void translate(double tx, double ty) {
-        transform.translate(tx,ty);
-    }
-    
-    /**
-     * @see Graphics2D#rotate(double)
-     */
-    public void rotate(double theta) {
-        transform.rotate(theta);
-    }
-    
-    /**
-     * @see Graphics2D#rotate(double, double, double)
-     */
-    public void rotate(double theta, double x, double y) {
-        transform.rotate(theta, x, y);
-    }
-    
-    /**
-     * @see Graphics2D#scale(double, double)
-     */
-    public void scale(double sx, double sy) {
-        transform.scale(sx, sy);
-        this.stroke = transformStroke(originalStroke);
-    }
-    
-    /**
-     * @see Graphics2D#shear(double, double)
-     */
-    public void shear(double shx, double shy) {
-        transform.shear(shx, shy);
-    }
-    
-    /**
-     * @see Graphics2D#transform(AffineTransform)
-     */
-    public void transform(AffineTransform tx) {
-        transform.concatenate(tx);
-        this.stroke = transformStroke(originalStroke);
-    }
-    
-    /**
-     * @see Graphics2D#setTransform(AffineTransform)
-     */
-    public void setTransform(AffineTransform t) {
-        transform = new AffineTransform(t);
-        this.stroke = transformStroke(originalStroke);
-    }
-    
-    /**
-     * @see Graphics2D#getTransform()
-     */
-    public AffineTransform getTransform() {
-        return new AffineTransform(transform);
-    }
-    
-    /**
-	 * Method contributed by Alexej Suchov
-     * @see Graphics2D#getPaint()
-     */
-    public Paint getPaint() {
-        if (realPaint != null) {
-            return realPaint;
-        } else {
-            return paint;
-        }
-	}
-    
-    /**
-     * @see Graphics2D#getComposite()
-     */
-    public Composite getComposite() {
-        return null;
-    }
-    
-    /**
-     * @see Graphics2D#setBackground(Color)
-     */
-    public void setBackground(Color color) {
-        background = color;
-    }
-    
-    /**
-     * @see Graphics2D#getBackground()
-     */
-    public Color getBackground() {
-        return background;
-    }
-    
-    /**
-     * @see Graphics2D#getStroke()
-     */
-    public Stroke getStroke() {
-        return originalStroke;
-    }
-    
-    
-    /**
-     * @see Graphics2D#getFontRenderContext()
-     */
-    public FontRenderContext getFontRenderContext() {
-        boolean antialias = RenderingHints.VALUE_TEXT_ANTIALIAS_ON.equals(getRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING));
-        boolean fractions = RenderingHints.VALUE_FRACTIONALMETRICS_ON.equals(getRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS));
-        return new FontRenderContext(new AffineTransform(), antialias, fractions);
-    }
-    
-    /**
-     * @see Graphics#create()
-     */
-    public Graphics create() {
-        PdfGraphics2D g2 = new PdfGraphics2D();
-        g2.onlyShapes = this.onlyShapes;
-        g2.transform = new AffineTransform(this.transform);
-        g2.baseFonts = this.baseFonts;
-        g2.fontMapper = this.fontMapper;
-        g2.paint = this.paint;
-        g2.fillGState = this.fillGState;
-        g2.strokeGState = this.strokeGState;
-        g2.background = this.background;
-        g2.mediaTracker = this.mediaTracker;
-        g2.convertImagesToJPEG = this.convertImagesToJPEG;
-        g2.jpegQuality = this.jpegQuality;
-        g2.setFont(this.font);
-        g2.cb = this.cb.getDuplicate();
-        g2.cb.saveState();
-        g2.width = this.width;
-        g2.height = this.height;
-        g2.followPath(new Area(new Rectangle2D.Float(0, 0, width, height)), CLIP);
-        if (this.clip != null)
-            g2.clip = new Area(this.clip);
-        g2.stroke = stroke;
-        g2.originalStroke = originalStroke;
-        g2.strokeOne = (BasicStroke)g2.transformStroke(g2.strokeOne);
-        g2.oldStroke = g2.strokeOne;
-        g2.setStrokeDiff(g2.oldStroke, null);
-        g2.cb.saveState();
-        if (g2.clip != null)
-            g2.followPath(g2.clip, CLIP);
-        g2.kid = true;
-        if (this.kids == null)
-            this.kids = new ArrayList();
-        this.kids.add(new Integer(cb.getInternalBuffer().size()));
-        this.kids.add(g2);
-        return g2;
-    }
-    
-    public PdfContentByte getContent() {
-        return this.cb;
-    }
-    /**
-     * @see Graphics#getColor()
-     */
-    public Color getColor() {
-        if (paint instanceof Color) {
-            return (Color)paint;
-        } else {
-            return Color.black;
-        }
-    }
-    
-    /**
-     * @see Graphics#setColor(Color)
-     */
-    public void setColor(Color color) {
-        setPaint(color);
-    }
-    
-    /**
-     * @see Graphics#setPaintMode()
-     */
-    public void setPaintMode() {}
-    
-    /**
-     * @see Graphics#setXORMode(Color)
-     */
-    public void setXORMode(Color c1) {
-        
-    }
-    
-    /**
-     * @see Graphics#getFont()
-     */
-    public Font getFont() {
-        return font;
-    }
-    
-    /**
-     * @see Graphics#setFont(Font)
-     */
-    /**
-     * Sets the current font.
-     */
-    public void setFont(Font f) {
-        if (f == null)
-            return;
-        if (onlyShapes) {
-            font = f;
-            return;
-        }
-        if (f == font)
-            return;
-        font = f;
-        fontSize = f.getSize2D();
-        baseFont = getCachedBaseFont(f);
-    }
-    
-    private BaseFont getCachedBaseFont(Font f) {
-        synchronized (baseFonts) {
-            BaseFont bf = (BaseFont)baseFonts.get(f.getFontName());
-            if (bf == null) {
-                bf = fontMapper.awtToPdf(f);
-                baseFonts.put(f.getFontName(), bf);
-            }
-            return bf;
-        }
-    }
-    
-    /**
-     * @see Graphics#getFontMetrics(Font)
-     */
-    public FontMetrics getFontMetrics(Font f) {
-        return dg2.getFontMetrics(f);
-    }
-    
-    /**
-     * @see Graphics#getClipBounds()
-     */
-    public Rectangle getClipBounds() {
-        if (clip == null)
-            return null;
-        return getClip().getBounds();
-    }
-    
-    /**
-     * @see Graphics#clipRect(int, int, int, int)
-     */
-    public void clipRect(int x, int y, int width, int height) {
-        Rectangle2D rect = new Rectangle2D.Double(x,y,width,height);
-        clip(rect);
-    }
-    
-    /**
-     * @see Graphics#setClip(int, int, int, int)
-     */
-    public void setClip(int x, int y, int width, int height) {
-        Rectangle2D rect = new Rectangle2D.Double(x,y,width,height);
-        setClip(rect);
-    }
-    
-    /**
-     * @see Graphics2D#clip(Shape)
-     */
-    public void clip(Shape s) {
-        if (s == null) {
-            setClip(null);
-            return;
-        }
-        s = transform.createTransformedShape(s);
-        if (clip == null)
-            clip = new Area(s);
+    if (drawType == STROKE)
+    {
+      setStrokeDiff(stroke, oldStroke);
+      oldStroke = stroke;
+      setStrokePaint();
+    }
+    else if (drawType == FILL)
+    {
+      setFillPaint();
+    }
+    final PathIterator points;
+    if (drawType == CLIP)
+    {
+      points = s.getPathIterator(IDENTITY);
+    }
+    else
+    {
+      points = s.getPathIterator(transform);
+    }
+    final float[] coords = new float[6];
+    int traces = 0;
+    while (!points.isDone())
+    {
+      ++traces;
+      final int segtype = points.currentSegment(coords);
+      normalizeY(coords);
+      switch (segtype)
+      {
+        case PathIterator.SEG_CLOSE:
+          cb.closePath();
+          break;
+
+        case PathIterator.SEG_CUBICTO:
+          cb.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
+          break;
+
+        case PathIterator.SEG_LINETO:
+          cb.lineTo(coords[0], coords[1]);
+          break;
+
+        case PathIterator.SEG_MOVETO:
+          cb.moveTo(coords[0], coords[1]);
+          break;
+
+        case PathIterator.SEG_QUADTO:
+          cb.curveTo(coords[0], coords[1], coords[2], coords[3]);
+          break;
+      }
+      points.next();
+    }
+    switch (drawType)
+    {
+      case FILL:
+        if (traces > 0)
+        {
+          if (points.getWindingRule() == PathIterator.WIND_EVEN_ODD)
+          {
+            cb.eoFill();
+          }
+          else
+          {
+            cb.fill();
+          }
+        }
+        break;
+      case STROKE:
+        if (traces > 0)
+        {
+          cb.stroke();
+        }
+        break;
+      default: //drawType==CLIP
+        if (traces == 0)
+        {
+          cb.rectangle(0, 0, 0, 0);
+        }
+        if (points.getWindingRule() == PathIterator.WIND_EVEN_ODD)
+        {
+          cb.eoClip();
+        }
         else
-            clip.intersect(new Area(s));
-        followPath(s, CLIP);
+        {
+          cb.clip();
+        }
+        cb.newPath();
     }
-    
-    /**
-     * @see Graphics#getClip()
-     */
-    public Shape getClip() {
-        try {
-            return transform.createInverse().createTransformedShape(clip);
-        }
-        catch (NoninvertibleTransformException e) {
-            return null;
-        }
-    }
-    
-    /**
-     * @see Graphics#setClip(Shape)
-     */
-    public void setClip(Shape s) {
-        cb.restoreState();
-        cb.saveState();
-        if (s != null)
-            s = transform.createTransformedShape(s);
-        if (s == null) {
-            clip = null;
-        }
-        else {
-            clip = new Area(s);
-            followPath(s, CLIP);
-        }
-        paintFill = paintStroke = null;
-        currentFillGState = currentStrokeGState = 255;
-        oldStroke = strokeOne;
-    }
-    
-    /**
-     * @see Graphics#copyArea(int, int, int, int, int, int)
-     */
-    public void copyArea(int x, int y, int width, int height, int dx, int dy) {
-        
-    }
-    
-    /**
-     * @see Graphics#drawLine(int, int, int, int)
-     */
-    public void drawLine(int x1, int y1, int x2, int y2) {
-        Line2D line = new Line2D.Double((double)x1, (double)y1, (double)x2, (double)y2);
-        draw(line);
+  }
+
+  private float normalizeY(final float y)
+  {
+    return this.height - y;
+  }
+
+  private void normalizeY(final float[] coords)
+  {
+    coords[1] = normalizeY(coords[1]);
+    coords[3] = normalizeY(coords[3]);
+    coords[5] = normalizeY(coords[5]);
+  }
+
+  private AffineTransform normalizeMatrix()
+  {
+    final double[] mx = new double[6];
+    AffineTransform result = AffineTransform.getTranslateInstance(0, 0);
+    result.getMatrix(mx);
+    mx[3] = -1;
+    mx[5] = height;
+    result = new AffineTransform(mx);
+    result.concatenate(transform);
+    return result;
+  }
+
+  private boolean drawImage(final Image img,
+                            final Image mask,
+                            final AffineTransform xform,
+                            final Color bgColor,
+                            final ImageObserver obs)
+  {
+    if (xform == null)
+    {
+      return true;
+    }
+
+    xform.translate(0, img.getHeight(obs));
+    xform.scale(img.getWidth(obs), img.getHeight(obs));
+
+    final AffineTransform inverse = this.normalizeMatrix();
+    final AffineTransform flipper = AffineTransform.getScaleInstance(1, -1);
+    inverse.concatenate(xform);
+    inverse.concatenate(flipper);
+
+    final double[] mx = new double[6];
+    inverse.getMatrix(mx);
+    if (currentFillGState != 255)
+    {
+      PdfGState gs = fillGState[255];
+      if (gs == null)
+      {
+        gs = new PdfGState();
+        gs.setFillOpacity(1);
+        fillGState[255] = gs;
+      }
+      cb.setGState(gs);
+    }
+
+    try
+    {
+      com.lowagie.text.Image image = null;
+      if (!convertImagesToJPEG)
+      {
+        image = com.lowagie.text.Image.getInstance(img, bgColor);
+      }
+      else
+      {
+        final BufferedImage scaled = new BufferedImage(img.getWidth(null), img.getHeight(null), BufferedImage.TYPE_INT_RGB);
+        final Graphics2D g3 = scaled.createGraphics();
+        g3.drawImage(img, 0, 0, img.getWidth(null), img.getHeight(null), null);
+        g3.dispose();
+
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        final com.sun.image.codec.jpeg.JPEGImageEncoder encoder = com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(baos);
+        final com.sun.image.codec.jpeg.JPEGEncodeParam param = com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(scaled);
+        param.setQuality(jpegQuality, true);
+        encoder.encode(scaled, param);
+        scaled.flush();
+        //scaled = null;
+        image = com.lowagie.text.Image.getInstance(baos.toByteArray());
+
+      }
+      if (mask != null)
+      {
+        final com.lowagie.text.Image msk = com.lowagie.text.Image.getInstance(mask, null, true);
+        msk.makeMask();
+        msk.setInvertMask(true);
+        image.setImageMask(msk);
+      }
+      cb.addImage(image, (float) mx[0], (float) mx[1], (float) mx[2], (float) mx[3], (float) mx[4], (float) mx[5]);
+    }
+    catch (Exception ex)
+    {
+      throw new IllegalArgumentException();
+    }
+    if (currentFillGState != 255)
+    {
+      final PdfGState gs = fillGState[currentFillGState];
+      cb.setGState(gs);
+    }
+    return true;
+  }
+
+  private boolean checkNewPaint(final Paint oldPaint)
+  {
+    if (paint == oldPaint)
+    {
+      return false;
+    }
+    return !((paint instanceof Color) && paint.equals(oldPaint));
+  }
+
+  private void setFillPaint()
+  {
+    if (checkNewPaint(paintFill))
+    {
+      paintFill = paint;
+      setPaint(false, 0, 0, true);
+    }
+  }
+
+  private void setStrokePaint()
+  {
+    if (checkNewPaint(paintStroke))
+    {
+      paintStroke = paint;
+      setPaint(false, 0, 0, false);
+    }
+  }
+
+  private void setPaint(final boolean invert, final double xoffset, final double yoffset, final boolean fill)
+  {
+    if (paint instanceof Color)
+    {
+      final Color color = (Color) paint;
+      final int alpha = color.getAlpha();
+      if (fill)
+      {
+        if (alpha != currentFillGState)
+        {
+          currentFillGState = alpha;
+          PdfGState gs = fillGState[alpha];
+          if (gs == null)
+          {
+            gs = new PdfGState();
+            gs.setFillOpacity((float) alpha / 255f);
+            fillGState[alpha] = gs;
+          }
+          cb.setGState(gs);
+        }
+        cb.setColorFill(color);
+      }
+      else
+      {
+        if (alpha != currentStrokeGState)
+        {
+          currentStrokeGState = alpha;
+          PdfGState gs = strokeGState[alpha];
+          if (gs == null)
+          {
+            gs = new PdfGState();
+            gs.setStrokeOpacity((float) alpha / 255f);
+            strokeGState[alpha] = gs;
+          }
+          cb.setGState(gs);
+        }
+        cb.setColorStroke(color);
+      }
+    }
+    else if (paint instanceof GradientPaint)
+    {
+      final GradientPaint gp = (GradientPaint) paint;
+      final Point2D p1 = gp.getPoint1();
+      transform.transform(p1, p1);
+      final Point2D p2 = gp.getPoint2();
+      transform.transform(p2, p2);
+      final Color c1 = gp.getColor1();
+      final Color c2 = gp.getColor2();
+      final PdfShading shading = PdfShading.simpleAxial(cb.getPdfWriter(), (float) p1.getX(), normalizeY((float) p1.getY()), (float) p2.getX(), normalizeY((float) p2.getY()), c1, c2);
+      final PdfShadingPattern pat = new PdfShadingPattern(shading);
+      if (fill)
+      {
+        cb.setShadingFill(pat);
+      }
+      else
+      {
+        cb.setShadingStroke(pat);
+      }
+    }
+    else if (paint instanceof TexturePaint)
+    {
+      try
+      {
+        final TexturePaint tp = (TexturePaint) paint;
+        final BufferedImage img = tp.getImage();
+        final Rectangle2D rect = tp.getAnchorRect();
+        final com.lowagie.text.Image image = com.lowagie.text.Image.getInstance(img, null);
+        final PdfPatternPainter pattern = cb.createPattern(image.width(), image.height());
+        final AffineTransform inverse = this.normalizeMatrix();
+        inverse.translate(rect.getX(), rect.getY());
+        inverse.scale(rect.getWidth() / image.width(), -rect.getHeight() / image.height());
+        final double[] mx = new double[6];
+        inverse.getMatrix(mx);
+        pattern.setPatternMatrix((float) mx[0], (float) mx[1], (float) mx[2], (float) mx[3], (float) mx[4], (float) mx[5]);
+        image.setAbsolutePosition(0, 0);
+        pattern.addImage(image);
+        if (fill)
+        {
+          cb.setPatternFill(pattern);
+        }
+        else
+        {
+          cb.setPatternStroke(pattern);
+        }
+      }
+      catch (Exception ex)
+      {
+        if (fill)
+        {
+          cb.setColorFill(Color.gray);
+        }
+        else
+        {
+          cb.setColorStroke(Color.gray);
+        }
+      }
     }
-    
-    /**
-     * @see Graphics#fillRect(int, int, int, int)
-     */
-    public void drawRect(int x, int y, int width, int height) {
-        draw(new Rectangle(x, y, width, height));
-    }
-    
-    /**
-     * @see Graphics#fillRect(int, int, int, int)
-     */
-    public void fillRect(int x, int y, int width, int height) {
-        fill(new Rectangle(x,y,width,height));
-    }
-    
-    /**
-     * @see Graphics#clearRect(int, int, int, int)
-     */
-    public void clearRect(int x, int y, int width, int height) {
-        Paint temp = paint;
-        setPaint(background);
-        fillRect(x,y,width,height);
-        setPaint(temp);
-    }
-    
-    /**
-     * @see Graphics#drawRoundRect(int, int, int, int, int, int)
-     */
-    public void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
-        RoundRectangle2D rect = new RoundRectangle2D.Double(x,y,width,height,arcWidth, arcHeight);
-        draw(rect);
-    }
-    
-    /**
-     * @see Graphics#fillRoundRect(int, int, int, int, int, int)
-     */
-    public void fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
-        RoundRectangle2D rect = new RoundRectangle2D.Double(x,y,width,height,arcWidth, arcHeight);
-        fill(rect);
-    }
-    
-    /**
-     * @see Graphics#drawOval(int, int, int, int)
-     */
-    public void drawOval(int x, int y, int width, int height) {
-        Ellipse2D oval = new Ellipse2D.Float((float)x, (float)y, (float)width, (float)height);
-        draw(oval);
-    }
-    
-    /**
-     * @see Graphics#fillOval(int, int, int, int)
-     */
-    public void fillOval(int x, int y, int width, int height) {
-        Ellipse2D oval = new Ellipse2D.Float((float)x, (float)y, (float)width, (float)height);
-        fill(oval);
-    }
-    
-    /**
-     * @see Graphics#drawArc(int, int, int, int, int, int)
-     */
-    public void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle) {
-        Arc2D arc = new Arc2D.Double(x,y,width,height,startAngle, arcAngle, Arc2D.OPEN);
-        draw(arc);
-
-    }
-    
-    /**
-     * @see Graphics#fillArc(int, int, int, int, int, int)
-     */
-    public void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle) {
-        Arc2D arc = new Arc2D.Double(x,y,width,height,startAngle, arcAngle, Arc2D.PIE);
-        fill(arc);
-    }
-    
-    /**
-     * @see Graphics#drawPolyline(int[], int[], int)
-     */
-    public void drawPolyline(int[] x, int[] y, int nPoints) {
-        Line2D line = new Line2D.Double(x[0],y[0],x[0],y[0]);
-        for (int i = 1; i < nPoints; i++) {
-            line.setLine(line.getX2(), line.getY2(), x[i], y[i]);
-            draw(line);
-        }
-    }
-    
-    /**
-     * @see Graphics#drawPolygon(int[], int[], int)
-     */
-    public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints) {
-        Polygon poly = new Polygon();
-        for (int i = 0; i < nPoints; i++) {
-            poly.addPoint(xPoints[i], yPoints[i]);
-        }
-        draw(poly);
-    }
-    
-    /**
-     * @see Graphics#fillPolygon(int[], int[], int)
-     */
-    public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints) {
-        Polygon poly = new Polygon();
-        for (int i = 0; i < nPoints; i++) {
-            poly.addPoint(xPoints[i], yPoints[i]);
-        }
-        fill(poly);
-    }
-    
-    /**
-     * @see Graphics#drawImage(Image, int, int, ImageObserver)
-     */
-    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
-        return drawImage(img, x, y, null, observer);
-    }
-    
-    /**
-     * @see Graphics#drawImage(Image, int, int, int, int, ImageObserver)
-     */
-    public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer) {
-        return drawImage(img, x, y, width, height, null, observer);
-    }
-    
-    /**
-     * @see Graphics#drawImage(Image, int, int, Color, ImageObserver)
-     */
-    public boolean drawImage(Image img, int x, int y, Color bgcolor, ImageObserver observer) {
-        waitForImage(img);
-        return drawImage(img, x, y, img.getWidth(observer), img.getHeight(observer), bgcolor, observer);
-    }
-    
-    /**
-     * @see Graphics#drawImage(Image, int, int, int, int, Color, ImageObserver)
-     */
-    public boolean drawImage(Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer) {
-        waitForImage(img);
-        double scalex = width/(double)img.getWidth(observer);
-        double scaley = height/(double)img.getHeight(observer);
-        AffineTransform tx = AffineTransform.getTranslateInstance(x,y);
-        tx.scale(scalex,scaley);
-        return drawImage(img, null, tx, bgcolor, observer);
-    }
-    
-    /**
-     * @see Graphics#drawImage(Image, int, int, int, int, int, int, int, int, ImageObserver)
-     */
-    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer) {
-        return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null, observer);
-    }
-    
-    /**
-     * @see Graphics#drawImage(Image, int, int, int, int, int, int, int, int, Color, ImageObserver)
-     */
-    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor, ImageObserver observer) {
-        waitForImage(img);
-        double dwidth = (double)dx2-dx1;
-        double dheight = (double)dy2-dy1;
-        double swidth = (double)sx2-sx1;
-        double sheight = (double)sy2-sy1;
-        
-        //if either width or height is 0, then there is nothing to draw
-        if (dwidth == 0 || dheight == 0 || swidth == 0 || sheight == 0) return true;
-        
-        double scalex = dwidth/swidth;
-        double scaley = dheight/sheight;
-        
-        double transx = sx1*scalex;
-        double transy = sy1*scaley;
-        AffineTransform tx = AffineTransform.getTranslateInstance(dx1-transx,dy1-transy);
-        tx.scale(scalex,scaley);
-        
-        BufferedImage mask = new BufferedImage(img.getWidth(observer), img.getHeight(observer), BufferedImage.TYPE_BYTE_BINARY);
-        Graphics g = mask.getGraphics();
-        g.fillRect(sx1,sy1, (int)swidth, (int)sheight);
-        drawImage(img, mask, tx, null, observer);
+    else
+    {
+      try
+      {
+        int type = BufferedImage.TYPE_4BYTE_ABGR;
+        if (paint.getTransparency() == Transparency.OPAQUE)
+        {
+          type = BufferedImage.TYPE_3BYTE_BGR;
+        }
+        final BufferedImage img = new BufferedImage((int) width, (int) height, type);
+        final Graphics2D g = (Graphics2D) img.getGraphics();
+        g.transform(transform);
+        final AffineTransform inv = transform.createInverse();
+        Shape fillRect = new Rectangle2D.Double(0, 0, img.getWidth(), img.getHeight());
+        fillRect = inv.createTransformedShape(fillRect);
+        g.setPaint(paint);
+        g.fill(fillRect);
+        if (invert)
+        {
+          final AffineTransform tx = new AffineTransform();
+          tx.scale(1, -1);
+          tx.translate(-xoffset, -yoffset);
+          g.drawImage(img, tx, null);
+        }
         g.dispose();
-        return true;
-    }
-    
-    /**
-     * @see Graphics#dispose()
-     */
-    public void dispose() {
-        if (kid)
-            return;
-        if (!disposeCalled) {
-            disposeCalled = true;
-            cb.restoreState();
-            cb.restoreState();
-            dg2.dispose();
-            dg2 = null;
-            if (kids != null) {
-                ByteBuffer buf = new ByteBuffer();
-                internalDispose(buf);
-                ByteBuffer buf2 = cb.getInternalBuffer();
-                buf2.reset();
-                buf2.append(buf);
-            }
-        }
-    }
-    
-    private void internalDispose(ByteBuffer buf) {
-        int last = 0;
-        int pos = 0;
-        ByteBuffer buf2 = cb.getInternalBuffer();
-        if (kids != null) {
-            for (int k = 0; k < kids.size(); k += 2) {
-                pos = ((Integer)kids.get(k)).intValue();
-                PdfGraphics2D g2 = (PdfGraphics2D)kids.get(k + 1);
-                g2.cb.restoreState();
-                g2.cb.restoreState();
-                buf.append(buf2.getBuffer(), last, pos - last);
-                g2.dg2.dispose();
-                g2.dg2 = null;
-                g2.internalDispose(buf);
-                last = pos;
-            }
-        }
-        buf.append(buf2.getBuffer(), last, buf2.size() - last);
-    }
-    
-    ///////////////////////////////////////////////
-    //
-    //
-    //		implementation specific methods
-    //
-    //
-    
-    
-    private void followPath(Shape s, int drawType) {
-        if (s==null) return;
-        if (drawType==STROKE) {
-            if (!(stroke instanceof BasicStroke)) {
-                s = stroke.createStrokedShape(s);
-                followPath(s, FILL);
-                return;
-            }
-        }
-        if (drawType==STROKE) {
-            setStrokeDiff(stroke, oldStroke);
-            oldStroke = stroke;
-            setStrokePaint();
-        }
-        else if (drawType==FILL)
-            setFillPaint();
-        PathIterator points;
-        int traces = 0;
-        if (drawType == CLIP)
-            points = s.getPathIterator(IDENTITY);
+        // g = null;
+        final com.lowagie.text.Image image = com.lowagie.text.Image.getInstance(img, null);
+        final PdfPatternPainter pattern = cb.createPattern(width, height);
+        image.setAbsolutePosition(0, 0);
+        pattern.addImage(image);
+        if (fill)
+        {
+          cb.setPatternFill(pattern);
+        }
         else
-            points = s.getPathIterator(transform);
-        float[] coords = new float[6];
-        while(!points.isDone()) {
-            ++traces;
-            int segtype = points.currentSegment(coords);
-            normalizeY(coords);
-            switch(segtype) {
-                case PathIterator.SEG_CLOSE:
-                    cb.closePath();
-                    break;
-
-                case PathIterator.SEG_CUBICTO:
-                    cb.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
-                    break;
-
-                case PathIterator.SEG_LINETO:
-                    cb.lineTo(coords[0], coords[1]);
-                    break;
-
-                case PathIterator.SEG_MOVETO:
-                    cb.moveTo(coords[0], coords[1]);
-                    break;
-
-                case PathIterator.SEG_QUADTO:
-                    cb.curveTo(coords[0], coords[1], coords[2], coords[3]);
-                    break;
-            }
-            points.next();
-        }
-        switch (drawType) {
-        case FILL:
-            if (traces > 0) {
-                if (points.getWindingRule() == PathIterator.WIND_EVEN_ODD)
-                    cb.eoFill();
-                else
-                    cb.fill();
-            }
-            break;
-        case STROKE:
-            if (traces > 0)
-                cb.stroke();
-            break;
-        default: //drawType==CLIP
-            if (traces == 0)
-                cb.rectangle(0, 0, 0, 0);
-            if (points.getWindingRule() == PathIterator.WIND_EVEN_ODD)
-                cb.eoClip();
-            else
-                cb.clip();
-            cb.newPath();
-        }
-    }
-    
-    private float normalizeY(float y) {
-        return this.height - y;
-    }
-    
-    private void normalizeY(float[] coords) {
-        coords[1] = normalizeY(coords[1]);
-        coords[3] = normalizeY(coords[3]);
-        coords[5] = normalizeY(coords[5]);
-    }
-    
-    private AffineTransform normalizeMatrix() {
-        double[] mx = new double[6];
-        AffineTransform result = AffineTransform.getTranslateInstance(0,0);
-        result.getMatrix(mx);
-        mx[3]=-1;
-        mx[5]=height;
-        result = new AffineTransform(mx);
-        result.concatenate(transform);
-        return result;
-    }
-    
-    private boolean drawImage(Image img, Image mask, AffineTransform xform, Color bgColor, ImageObserver obs) {
-        if (xform==null) return true;
-        
-        xform.translate(0, img.getHeight(obs));
-        xform.scale(img.getWidth(obs), img.getHeight(obs));
-        
-        AffineTransform inverse = this.normalizeMatrix();
-        AffineTransform flipper = AffineTransform.getScaleInstance(1,-1);
-        inverse.concatenate(xform);
-        inverse.concatenate(flipper);
-        
-        double[] mx = new double[6];
-        inverse.getMatrix(mx);
-        if (currentFillGState != 255) {
-            PdfGState gs = fillGState[255];
-            if (gs == null) {
-                gs = new PdfGState();
-                gs.setFillOpacity(1);
-                fillGState[255] = gs;
-            }
-            cb.setGState(gs);
-        }
-        
-        try {
-            com.lowagie.text.Image image = null;
-            if(!convertImagesToJPEG){
-                image = com.lowagie.text.Image.getInstance(img, bgColor);
-            }
-            else{
-                BufferedImage scaled = new BufferedImage(img.getWidth(null), img.getHeight(null), BufferedImage.TYPE_INT_RGB);
-                Graphics2D g3 = scaled.createGraphics();
-                g3.drawImage(img, 0, 0, img.getWidth(null), img.getHeight(null), null);
-                g3.dispose();
-                
-                ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                com.sun.image.codec.jpeg.JPEGImageEncoder encoder = com.sun.image.codec.jpeg.JPEGCodec.createJPEGEncoder(baos);
-                com.sun.image.codec.jpeg.JPEGEncodeParam param = com.sun.image.codec.jpeg.JPEGCodec.getDefaultJPEGEncodeParam(scaled);
-                param.setQuality(jpegQuality, true);
-                encoder.encode(scaled, param);
-                scaled.flush();
-                scaled = null;
-                image = com.lowagie.text.Image.getInstance(baos.toByteArray());
-                
-            }
-            if (mask!=null) {
-                com.lowagie.text.Image msk = com.lowagie.text.Image.getInstance(mask, null, true);
-                msk.makeMask();
-                msk.setInvertMask(true);
-                image.setImageMask(msk);
-            }
-            cb.addImage(image, (float)mx[0], (float)mx[1], (float)mx[2], (float)mx[3], (float)mx[4], (float)mx[5]);
-        } catch (Exception ex) {
-            throw new IllegalArgumentException();
-        }
-        if (currentFillGState != 255) {
-            PdfGState gs = fillGState[currentFillGState];
-            cb.setGState(gs);
-        }        
-        return true;
-    }
-    
-    private boolean checkNewPaint(Paint oldPaint) {
-        if (paint == oldPaint)
-            return false;
-        return !((paint instanceof Color) && paint.equals(oldPaint));
-    }
-    
-    private void setFillPaint() {
-        if (checkNewPaint(paintFill)) {
-            paintFill = paint;
-            setPaint(false, 0, 0, true);
-        }
-    }
-    
-    private void setStrokePaint() {
-        if (checkNewPaint(paintStroke)) {
-            paintStroke = paint;
-            setPaint(false, 0, 0, false);
-        }
-    }
-    
-    private void setPaint(boolean invert, double xoffset, double yoffset, boolean fill) {
-        if (paint instanceof Color) {
-            Color color = (Color)paint;
-            int alpha = color.getAlpha();
-            if (fill) {
-                if (alpha != currentFillGState) {
-                    currentFillGState = alpha;
-                    PdfGState gs = fillGState[alpha];
-                    if (gs == null) {
-                        gs = new PdfGState();
-                        gs.setFillOpacity((float)alpha / 255f);
-                        fillGState[alpha] = gs;
-                    }
-                    cb.setGState(gs);
-                }
-                cb.setColorFill(color);
-            }
-            else {
-                if (alpha != currentStrokeGState) {
-                    currentStrokeGState = alpha;
-                    PdfGState gs = strokeGState[alpha];
-                    if (gs == null) {
-                        gs = new PdfGState();
-                        gs.setStrokeOpacity((float)alpha / 255f);
-                        strokeGState[alpha] = gs;
-                    }
-                    cb.setGState(gs);
-                }
-                cb.setColorStroke(color);
-            }
-        }
-        else if (paint instanceof GradientPaint) {
-            GradientPaint gp = (GradientPaint)paint;
-            Point2D p1 = gp.getPoint1();
-            transform.transform(p1, p1);
-            Point2D p2 = gp.getPoint2();
-            transform.transform(p2, p2);
-            Color c1 = gp.getColor1();
-            Color c2 = gp.getColor2();
-            PdfShading shading = PdfShading.simpleAxial(cb.getPdfWriter(), (float)p1.getX(), normalizeY((float)p1.getY()), (float)p2.getX(), normalizeY((float)p2.getY()), c1, c2);
-            PdfShadingPattern pat = new PdfShadingPattern(shading);
-            if (fill)
-                cb.setShadingFill(pat);
-            else
-                cb.setShadingStroke(pat);
-        }
-        else if (paint instanceof TexturePaint) {
-            try {
-                TexturePaint tp = (TexturePaint)paint;
-                BufferedImage img = tp.getImage();
-                Rectangle2D rect = tp.getAnchorRect();
-                com.lowagie.text.Image image = com.lowagie.text.Image.getInstance(img, null);
-                PdfPatternPainter pattern = cb.createPattern(image.width(), image.height());
-                AffineTransform inverse = this.normalizeMatrix();
-                inverse.translate(rect.getX(), rect.getY());
-                inverse.scale(rect.getWidth() / image.width(), -rect.getHeight() / image.height());
-                double[] mx = new double[6];
-                inverse.getMatrix(mx);
-                pattern.setPatternMatrix((float)mx[0], (float)mx[1], (float)mx[2], (float)mx[3], (float)mx[4], (float)mx[5]) ;
-                image.setAbsolutePosition(0,0);
-                pattern.addImage(image);
-                if (fill)
-                    cb.setPatternFill(pattern);
-                else
-                    cb.setPatternStroke(pattern);
-            } catch (Exception ex) {
-                if (fill)
-                    cb.setColorFill(Color.gray);
-                else
-                    cb.setColorStroke(Color.gray);
-            }
-        }
-        else {
-            try {
-                BufferedImage img = null;
-                int type = BufferedImage.TYPE_4BYTE_ABGR;
-                if (paint.getTransparency() == Transparency.OPAQUE) {
-                    type = BufferedImage.TYPE_3BYTE_BGR;
-                }
-                img = new BufferedImage((int)width, (int)height, type);
-                Graphics2D g = (Graphics2D)img.getGraphics();
-                g.transform(transform);
-                AffineTransform inv = transform.createInverse();
-                Shape fillRect = new Rectangle2D.Double(0,0,img.getWidth(),img.getHeight());
-                fillRect = inv.createTransformedShape(fillRect);
-                g.setPaint(paint);
-                g.fill(fillRect);
-                if (invert) {
-                    AffineTransform tx = new AffineTransform();
-                    tx.scale(1,-1);
-                    tx.translate(-xoffset,-yoffset);
-                    g.drawImage(img,tx,null);
-                }
-                g.dispose();
-                g = null;
-                com.lowagie.text.Image image = com.lowagie.text.Image.getInstance(img, null);
-                PdfPatternPainter pattern = cb.createPattern(width, height);
-                image.setAbsolutePosition(0,0);
-                pattern.addImage(image);
-                if (fill)
-                    cb.setPatternFill(pattern);
-                else
-                    cb.setPatternStroke(pattern);
-            } catch (Exception ex) {
-                if (fill)
-                    cb.setColorFill(Color.gray);
-                else
-                    cb.setColorStroke(Color.gray);
-            }
-        }
-    }
-    
-    private synchronized void waitForImage(java.awt.Image image) {
-        if (mediaTracker == null)
-            mediaTracker = new MediaTracker(new PdfGraphics2D.fakeComponent());
-        mediaTracker.addImage(image, 0);
-        try {
-            mediaTracker.waitForID(0);
-        }
-        catch (InterruptedException e) {
-            // empty on purpose
+        {
+          cb.setPatternStroke(pattern);
+        }
+      }
+      catch (Exception ex)
+      {
+        if (fill)
+        {
+          cb.setColorFill(Color.gray);
         }
-        mediaTracker.removeImage(image);
+        else
+        {
+          cb.setColorStroke(Color.gray);
+        }
+      }
     }
-        
-    static private class fakeComponent extends Component {
+  }
 
-		private static final long serialVersionUID = 6450197945596086638L;
+  private synchronized void waitForImage(final java.awt.Image image)
+  {
+    if (mediaTracker == null)
+    {
+      mediaTracker = new MediaTracker(new FakeComponent());
+    }
+    mediaTracker.addImage(image, 0);
+    try
+    {
+      mediaTracker.waitForID(0);
     }
+    catch (InterruptedException e)
+    {
+      // empty on purpose
+    }
+    mediaTracker.removeImage(image);
+  }
+
+  private static class FakeComponent extends Component
+  {
+    public FakeComponent()
+    {
+    }
+
+    private static final long serialVersionUID = 6450197945596086638L;
+  }
 }
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/pdf/RandomAccessFileOrArray.java itext-1.5.2-jdk12/src/com/lowagie/text/pdf/RandomAccessFileOrArray.java
--- itext-1.5.2/src/com/lowagie/text/pdf/RandomAccessFileOrArray.java	2006-10-02 23:09:00.000000000 +0200
+++ itext-1.5.2-jdk12/src/com/lowagie/text/pdf/RandomAccessFileOrArray.java	2007-06-13 20:46:33.000000000 +0200
@@ -66,7 +66,7 @@
  */
 public class RandomAccessFileOrArray implements DataInput {
     
-    MappedRandomAccessFile rf;
+    RandomAccessFileWrapper rf;
     String filename;
     byte arrayIn[];
     int arrayInPtr;
@@ -118,7 +118,7 @@
         	return;
         }
         this.filename = filename;
-        rf = new MappedRandomAccessFile(filename, "r");
+        rf = new OldRandomAccessFile(filename, "r");
     }
 
     public RandomAccessFileOrArray(URL url) throws IOException {
@@ -261,7 +261,7 @@
     
     public void reOpen() throws IOException {
         if (filename != null && rf == null)
-            rf = new MappedRandomAccessFile(filename, "r");
+            rf = new OldRandomAccessFile(filename, "r");
         seek(0);
     }
     
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/pdf/RandomAccessFileWrapper.java itext-1.5.2-jdk12/src/com/lowagie/text/pdf/RandomAccessFileWrapper.java
--- itext-1.5.2/src/com/lowagie/text/pdf/RandomAccessFileWrapper.java	1970-01-01 01:00:00.000000000 +0100
+++ itext-1.5.2-jdk12/src/com/lowagie/text/pdf/RandomAccessFileWrapper.java	2007-06-13 20:44:36.000000000 +0200
@@ -0,0 +1,23 @@
+package com.lowagie.text.pdf;
+
+import java.io.IOException;
+
+/**
+ * Creation-Date: 13.06.2007, 20:42:57
+ *
+ * @author Thomas Morgner
+ */
+public interface RandomAccessFileWrapper
+{
+  int read() throws IOException;
+
+  int read(byte bytes[], int off, int len) throws IOException;
+
+  long getFilePointer()  throws IOException;
+
+  void seek(long pos)  throws IOException;
+
+  long length()  throws IOException;
+
+  void close() throws IOException;
+}
diff --exclude classes --exclude itext-1.5.2.iml --exclude itext-1.5.2.ipr --exclude itext-1.5.2.iws -Nru itext-1.5.2/src/com/lowagie/text/pdf/sun.txt itext-1.5.2-jdk12/src/com/lowagie/text/pdf/sun.txt
--- itext-1.5.2/src/com/lowagie/text/pdf/sun.txt	1970-01-01 01:00:00.000000000 +0100
+++ itext-1.5.2-jdk12/src/com/lowagie/text/pdf/sun.txt	2006-09-08 11:18:14.000000000 +0200
@@ -0,0 +1,66 @@
+Some classes in iText are based on code samples provided by SUN.
+A copyright notice is always included in the source code of the specific class.
+
+The license is either SUN's samples license (1), or the license marked with (2).
+
+----------------------------------------------------------------------------------
+(1) http://java.sun.com/products/java-media/2D/samples/samples-license.html
+
+READ THE FOLLOWING AGREEMENT BEFORE INSTALLING OR USING THE SAMPLE SOFTWARE.
+BY DOWNLOADING THIS SAMPLE SOFTWARE, YOU ACCEPT AND AGREE TO THE TERMS AND
+CONDITIONS BELOW. IF YOU DO NOT AGREE, DO NOT DOWNLOAD OR USE THE SAMPLE SOFTWARE.
+
+Sun Microsystems grants you ("Licensee") a non-exclusive, royalty free, license
+to use, modify and redistribute this software in source and binary code form,
+provided that i) this copyright notice and license appear on all copies of the
+software; and ii) Licensee does not utilize the software in a manner which is
+disparaging to Sun Microsystems.
+
+The software media is distributed on an "As Is" basis, without warranty.
+Neither the authors, the software developers nor Sun Microsystems make any
+representation, or warranty, either express or implied, with respect to the
+software programs, their quality, accuracy, or fitness for a specific purpose.
+Therefore, neither the authors, the software developers nor Sun Microsystems
+shall have any liability to you or any other person or entity with respect
+to any liability, loss, or damage caused or alleged to have been caused
+directly or indirectly by programs contained on the media. This includes,
+but is not limited to, interruption of service, loss of data, loss of
+classroom time, loss of consulting or anticipatory profits, or consequential
+damages from the use of these programs.
+
+----------------------------------------------------------------------------------
+(2) SUN license for a handful of classes in iText:
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+-Redistributions of source code must retain the above copyright notice, this
+ list of conditions and the following disclaimer.
+
+-Redistribution in binary form must reproduct the above copyright notice,
+ this list of conditions and the following disclaimer in the documentation
+ and/or other materials provided with the distribution.
+
+Neither the name of Sun Microsystems, Inc. or the names of contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+This software is provided "AS IS," without a warranty of any kind. ALL
+EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY
+IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+NON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN AND ITS LICENSORS SHALL NOT BE
+LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
+OR DISTRIBUTING THE SOFTWARE OR ITS DERIVATIVES. IN NO EVENT WILL SUN OR ITS
+LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT,
+INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER
+CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF
+OR INABILITY TO USE SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+You acknowledge that Software is not designed,licensed or intended for use in
+the design, construction, operation or maintenance of any nuclear facility.
+
+----------------------------------------------------------------------------------
+
+A complete list of the Intellectual Property of iText can be found
+at this address: http://itext.ugent.be/library/source/
\ Kein Zeilenumbruch am Dateiende.
